var documenterSearchIndex = {"docs":
[{"location":"families/","page":"Float Families","title":"Float Families","text":"For each member of this family of floating-point formats, this package provides the encoding and paired value sequence. There are two sorts of ML floats, Signed and Unsigned. There are two kinds of each, Finite and Extended. All have one NaN value and one Zero value. Extended kinds have a [signed] infinity, while Finite kinds do not.","category":"page"},{"location":"families/","page":"Float Families","title":"Float Families","text":"Signed\nFinite\nExtended\nUnsigned\nFinite\nExtended","category":"page"},{"location":"families/","page":"Float Families","title":"Float Families","text":"Sort Kind 1 NaN 1 Zero Infinity Family Generalized Name\nSigned Finite yes yes N/A SFinite sùöèBinary bitwidth P precision\nSigned Extended yes yes ¬±Inf SExtended seBinary bitwidth P precision\nUnsigned Finite yes yes N/A UFinite uùöèBinary bitwidth P precision\nUnsigned Extended yes yes +Inf UExtended ueBinary bitwidth P precision","category":"page"},{"location":"families/","page":"Float Families","title":"Float Families","text":"The bitwidths of the members of each family may be as low as 2 and as large as 15. The admissible precisions range from 1 through bitwidth-1.  ","category":"page"},{"location":"families/","page":"Float Families","title":"Float Families","text":"All value sequences have subnormals except for precisions of 1.","category":"page"},{"location":"families/","page":"Float Families","title":"Float Families","text":"","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"Here is a carefully structured Markdown documentation for the JeffreySarnoff/AIFloats.jl repository, based on the contents of src/AIFloats.jl and inferred design:","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"","category":"page"},{"location":"information/#AIFloats.jl","page":"Description","title":"AIFloats.jl","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"The internal constructive model for MicroFloats.   A Julia package for modeling and working with abstract and concrete floating point types, supporting both signed/unsigned and finite/extended (Inf-supporting) variants.","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"","category":"page"},{"location":"information/#Table-of-Contents","page":"Description","title":"Table of Contents","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"Overview\nInstallation\nModule Exports\nCore Concepts\nType Hierarchy\nKey Functions\nUsage Examples\nDependencies\nDevelopment\nLicense","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"","category":"page"},{"location":"information/#Overview","page":"Description","title":"Overview","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"AIFloats.jl provides a flexible and extensible framework for defining and working with floating-point types. This includes support for various encodings, bit widths, signedness, and finite or extended (Inf-supporting) domains. It is intended for research, experimentation, or custom numerical types.","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"","category":"page"},{"location":"information/#Installation","page":"Description","title":"Installation","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"import Pkg\nPkg.add(url=\"https://github.com/JeffreySarnoff/AIFloats.jl.git\")","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"","category":"page"},{"location":"information/#Module-Exports","page":"Description","title":"Module Exports","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"The main exports from the AIFloats module are:","category":"page"},{"location":"information/#Abstract-Types","page":"Description","title":"Abstract Types","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"AbstractAIFloat\nAbsUnsignedFloat / AbsUnsignedFiniteFloat / AbsUnsignedExtendedFloat\nAbsSignedFloat / AbsSignedFiniteFloat / AbsSignedExtendedFloat","category":"page"},{"location":"information/#Concrete-Types-and-Constructors","page":"Description","title":"Concrete Types & Constructors","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"floats, codes\nAIFloat ‚Äî generalized constructor\nUnsignedFiniteFloats, UnsignedExtendedFloats\nSignedFiniteFloats, SignedExtendedFloats","category":"page"},{"location":"information/#Typed-Predicates","page":"Description","title":"Typed Predicates","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"is_aifloat, is_unsigned, is_signed, is_finite, is_extended","category":"page"},{"location":"information/#Functions-Over-Types","page":"Description","title":"Functions Over Types","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"encoding_sequence, value_sequence\nmagnitude_sequence, foundation_magnitudes","category":"page"},{"location":"information/#Bit/Value-Counts","page":"Description","title":"Bit/Value Counts","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"nBits, nSigBits, nFracBits, nSignBits, nExpBits\nnNaNs, nZeros, nInfs, nPosInfs, nNegInfs\nnPrenormalMagnitudes, nSubnormalMagnitudes, nNormalMagnitudes, nMagnitudes\nnValues, nNumericValues, nNonzeroNumericValues\nnMagnitudes, nNonzeroMagnitudes\nnExpValues, nNonzeroExpValues\nnFiniteValues, nNonzeroFiniteValues","category":"page"},{"location":"information/#Exponent-Utilities","page":"Description","title":"Exponent Utilities","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"expBias, expUnbiasedValues, expMinValue, expMaxValue, expValues","category":"page"},{"location":"information/#Julia-Support-Functions","page":"Description","title":"Julia Support Functions","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"index1, indexneg1, valuetoindex, indextovalue, floatleast\nulp_distance","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"","category":"page"},{"location":"information/#Core-Concepts","page":"Description","title":"Core Concepts","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"AbstractAIFloat: Root for all AI float types.\nSignedness: Support for both signed and unsigned floats.\nFiniteness: Both finite (no infinities) and extended (with ¬±Inf) types.\nBit Layout: Customizable bit widths, exponent, and significand size.","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"","category":"page"},{"location":"information/#Type-Hierarchy","page":"Description","title":"Type Hierarchy","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"AbstractAIFloat\n ‚îú‚îÄ AbsUnsignedFloat\n ‚îÇ   ‚îú‚îÄ AbsUnsignedFiniteFloat\n ‚îÇ   ‚îî‚îÄ AbsUnsignedExtendedFloat\n ‚îî‚îÄ AbsSignedFloat\n     ‚îú‚îÄ AbsSignedFiniteFloat\n     ‚îî‚îÄ AbsSignedExtendedFloat","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"Concrete types are constructed via the AIFloat function and specialized subtypes, parameterized by bit width, significand bits, signedness, and extension.","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"","category":"page"},{"location":"information/#Key-Functions","page":"Description","title":"Key Functions","text":"","category":"section"},{"location":"information/#Generalized-Constructor","page":"Description","title":"Generalized Constructor","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"AIFloat(bits::Int, sigbits::Int; signed::Bool, extended::Bool)","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"Instantiates the appropriate AI float concrete type depending on the parameters.","category":"page"},{"location":"information/#Typed-Predicates-2","page":"Description","title":"Typed Predicates","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"is_aifloat(x): True if x is an AI float type.\nis_unsigned(x), is_signed(x), is_finite(x), is_extended(x): Type properties.","category":"page"},{"location":"information/#Bit/Value-Analysis","page":"Description","title":"Bit/Value Analysis","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"Functions such as nBits, nSigBits, nExpBits, nMagnitudes, nValues, etc., return details about the bit structure and value set for a given type.","category":"page"},{"location":"information/#Sequences","page":"Description","title":"Sequences","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"encoding_sequence, value_sequence, magnitude_sequence, foundation_magnitudes: Enumerate underlying representations and corresponding values.","category":"page"},{"location":"information/#Julia-Support","page":"Description","title":"Julia Support","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"Indexing and conversion helpers: index1, indexneg1, valuetoindex, indextovalue, floatleast, ulp_distance.","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"","category":"page"},{"location":"information/#Usage-Examples","page":"Description","title":"Usage Examples","text":"","category":"section"},{"location":"information/#Constructing-a-Custom-Float-Type","page":"Description","title":"Constructing a Custom Float Type","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"using AIFloats\n\n# Create a 16-bit signed, extended (Inf-supporting) float type\nT = AIFloat(16, 11; signed=true, extended=true)\n\n# Query some properties\nnBits(T)            # Number of bits\nnFiniteValues(T)    # Number of finite representable values","category":"page"},{"location":"information/#Checking-Type-Properties","page":"Description","title":"Checking Type Properties","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"is_signed(T)   # true\nis_extended(T) # true","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"","category":"page"},{"location":"information/#Dependencies","page":"Description","title":"Dependencies","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"AlignedAllocs.jl\nStatic.jl","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"","category":"page"},{"location":"information/#Development","page":"Description","title":"Development","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"The main module includes and organizes its logic across several source files:","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"type/constants.jl ‚Äî type-level constants\ntype/abstract.jl ‚Äî abstract type definitions\nsupport/indices.jl ‚Äî helper functions for indexing\nconcrete/encodings.jl ‚Äî concrete encoding definitions\nconcrete/foundation.jl ‚Äî foundation logic for concrete types\nconcrete/unsigned.jl and concrete/signed.jl ‚Äî unsigned/signed types\nsupport/julialang.jl ‚Äî Julia language support and integration","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"","category":"page"},{"location":"information/#License","page":"Description","title":"License","text":"","category":"section"},{"location":"information/","page":"Description","title":"Description","text":"[Specify your license here.]","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"Note: For further details, please refer to the individual source files and Julia docstrings as implemented in the codebase.","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"","category":"page"},{"location":"information/","page":"Description","title":"Description","text":"","category":"page"},{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#AIFloats.CODE","page":"Reference","title":"AIFloats.CODE","text":"CODE\n\nThe built-in Unsigned Integer types available for encodings.\n\nUInt8 for bitwidths <= 8\nUInt16 for bitwidths > 8\n\nsee also FLOAT\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#AIFloats.CODE_TYPES","page":"Reference","title":"AIFloats.CODE_TYPES","text":"CODE\n\nThe built-in Unsigned Integer types available for encodings.\n\nUInt8 for bitwidths <= 8\nUInt16 for bitwidths > 8\n\nsee also FLOAT\n\n\n\n\n\n","category":"constant"},{"location":"95-reference/#AIFloats.FLOAT","page":"Reference","title":"AIFloats.FLOAT","text":"FLOAT\n\nThe built-in floating-point types available for valuations.\n\nFloat32 for bitwidths  <= 7\nFloat64 for bitwidths  > 8\nFloat128 for bitwidths > 11\n\nsee also CODE\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#AIFloats.FLOAT_TYPES","page":"Reference","title":"AIFloats.FLOAT_TYPES","text":"FLOAT\n\nThe built-in floating-point types available for valuations.\n\nFloat32 for bitwidths  <= 7\nFloat64 for bitwidths  > 8\nFloat128 for bitwidths > 11\n\nsee also CODE\n\n\n\n\n\n","category":"constant"},{"location":"95-reference/#AIFloats.index_to_code","page":"Reference","title":"AIFloats.index_to_code","text":"index_to_code(bits, index)\n\nconvert the Julia index x into a P3109 encoding value as a UInt8|16\n\n(8, 256) ‚Ü¶ 0xff\n(9, 256) ‚Ü¶ 0x00ff\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.index_to_offset","page":"Reference","title":"AIFloats.index_to_offset","text":"indextooffset(x)\n\nconvert the Julia index x into a P3109 offset as a UInt16\n\n(0x040) ‚Ü¶ 0x0039\nin 0-based languages, this is a do nothing operation\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.offset_to_index","page":"Reference","title":"AIFloats.offset_to_index","text":"offset_to_index(x)\n\nconvert the P3109 encoding x into a Julia index as an UInt16\n\n(0x39) ‚Ü¶ 0x0040\n(255) ‚Ü¶ 0x01\nin 0-based languages, this is a do nothing operation\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.typeforcode","page":"Reference","title":"AIFloats.typeforcode","text":"typeforcode(bitwidth)\n\nThe bitstype to be used for encoding values of bitwidth\n\nIt is an unchecked error to set bitwidth outside BitsMin..BitsMax\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.typeforfloat","page":"Reference","title":"AIFloats.typeforfloat","text":"typeforfloat(bitwidth)\n\nThe bitstype to be used for storing values of bitwidth\n\nIt is an unchecked error to set bitwidth outside BitsMin..BitsMax\n\n\n\n\n\n","category":"function"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"rationalseq/","page":"-","title":"-","text":"https://chatgpt.com/g/g-kZ0eYXlJe-scholar-gpt/c/67ef77b5-df50-8005-b87b-3dfd7ca20a85 a is there a name for the sequence (K > 2): 1/K, 2/K, .., (K-2)/K, (K-1)/K","category":"page"},{"location":"rationalseq/","page":"-","title":"-","text":"If you include 0 and 1, it's usually called a uniform grid over [0,1] with K+1 points.","category":"page"},{"location":"rationalseq/","page":"-","title":"-","text":"Uniform Rational Subdivision (excluding endpoints) It comes from dividing the unit interval [0,1] into K equal parts and then excluding 0 and 1:     [0,1] with K+1 points:","category":"page"},{"location":"rationalseq/","page":"-","title":"-","text":"Yes! The sequence you're describing is a uniformly spaced sequence of rational numbers between  1/K .. (K‚àí1)/K, with step size 1/K, excluding the endpoints 0 and 1.","category":"page"},{"location":"rationalseq/","page":"-","title":"-","text":"There isn't a widely-used special name for this exact sequence in general mathematical literature, but it's most commonly understood and referred to as:","category":"page"},{"location":"rationalseq/","page":"-","title":"-","text":"üîπ Uniform Rational Subdivision (excluding endpoints) It comes from dividing the unit interval  [0,1] into ùêæ (K equal parts and then excluding 0 and 1)","category":"page"},{"location":"rationalseq/","page":"-","title":"-","text":"","category":"page"},{"location":"sequence/","page":"The foundational sequence","title":"The foundational sequence","text":"this development immediately pertains to binaryKpP, where P ‚àà {2..K-1}.[a]","category":"page"},{"location":"sequence/","page":"The foundational sequence","title":"The foundational sequence","text":"each finite value in the [nonnegative portion of a] value sequence is a arithmetic composition of three components:","category":"page"},{"location":"sequence/","page":"The foundational sequence","title":"The foundational sequence","text":"a trailing significand (a nonnegative integer in the range [0, 2^P-1])\nthis is a fractional binary value\nan implicit leading bit {0b0, 0b1}\nthe finite value is subnormal when the implicit bit is 0b0 and the trailing significand is non-zero\nthe finite value is normal when the implicit bit is 1b1, whatever the trailing significand may be.\nan exponent (stored as a nonnegative integer in the range [0, 2^(K-P)-1])\nthe exponent is biased (all values >= 0)\nto recover its constructive value, subtract the bias (2^(K-P-1)-1) from the biased value.\nthe exponent acts multiplicatively as 2^exponent","category":"page"},{"location":"sequence/","page":"The foundational sequence","title":"The foundational sequence","text":"each finite value in the [nonnegative portion of a] value sequence is determined with:     value = (2^unbiased_exponent) * (implicit_bit + (trailing_significand_bits / 2^P))","category":"page"},{"location":"sequence/","page":"The foundational sequence","title":"The foundational sequence","text":"value = (2^unbiased_exponent) * (implicit_bit) + (2^unbiased_exponent) * (trailing_significand / 2^P))\nvalue = (2^unbiased_exponent) * (implicit_bit) + ((2^unbiased_exponent)/2^P) * (trailing_significand / 1))\nvalue = (2^unbiased_exponent) * (implicit_bit) + (2^(unbiased_exponent-P) * trailing_significand)\n\nsubnormal value = (2^unbiased_exponent) * (0b0) + (2^(unbiased_exponent-P) * trailing_significand)\nsubnormal value = (2^(unbiased_exponent-P) * trailing_significand)\nsubnormal value = (2^(unbiased_exponent_min) * trailing_significand)\n\nnormal value = (2^unbiased_exponent) * (0b1) + (2^(unbiased_exponent-P) * trailing_significand)\nnormal value = (2^unbiased_exponent) + (2^(unbiased_exponent-P) * trailing_significand)\n\nnormal_value = (2^unbiased_exponent) + subnormal_value","category":"page"},{"location":"sequence/","page":"The foundational sequence","title":"The foundational sequence","text":"[a]: Floating-point value sequences that have no subnormal values are eccentric.","category":"page"},{"location":"sequence/","page":"The foundational sequence","title":"The foundational sequence","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"Unit Fractions 1/K and (K‚Äì1)/K in Number Theory Introduction Unit fractions ‚Äì fractions with numerator 1 ‚Äì are the simplest rational numbers, and their complements of the form (K-1)K (just one unit fraction shy of 1) also yield interesting properties. For example, 1K and (K-1)K = 1 - 1K are obviously related (their sum is 1), but this simple relationship belies a rich structure. These forms appear throughout number theory, from ancient Egyptian fraction notation to modern conjectures about rational Diophantine equations. In this report, we explore the properties of 1K and (K-1)K, how they relate to general rational numbers, and their role in various number-theoretic contexts. We will see historical methods of representing fractions using such terms, patterns and identities involving these fractions, and connections to topics like modular arithmetic, Egyptian fractions, and Diophantine equations. Examples and theorems from both classical and contemporary mathematics will illustrate the significance of these simple fractions. Historical Context: Egyptian Fractions","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"K=7 1/K == 1/(K+1) + 1/(K * (K+1))","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"Figure: A portion of the Rhind Mathematical Papyrus (c. 1550 BC), which includes tables decomposing fractions like 2n into unit fractions‚Äã EN.WIKIPEDIA.ORG . The ancient Egyptians expressed rational numbers as sums of distinct unit fractions (with a few exceptions for certain forms like tfrac23). In their notation, 12 13 14 dots were written with special hieroglyphic symbols, and any fraction tfracab with ab was represented as a sum of such unit fractions (an Egyptian fraction). Notably, they allowed a couple of non-unit fractions as special cases: they had symbols for tfrac23 and tfrac34‚Äã EN.WIKIPEDIA.ORG . In fact, when a fraction larger than 12 needed to be expressed, scribes would often subtract one of these standard complements (like 23 or 34) and then express the remainder as a sum of unit fractions‚Äã EN.WIKIPEDIA.ORG . For example, tfrac34 might be taken as a single summand (since tfrac34 = 1 - tfrac14 is one unit fraction short of 1), or tfrac23 as a summand (since tfrac23 = 1 - tfrac13). This shows that complements of unit fractions were an integral part of Egyptian representations. A famous example appears in the Rhind Mathematical Papyrus (also called the Ahmes Papyrus, ~1650 BC). The papyrus begins with a table decomposing fractions of the form 2n (for odd n from 3 to 101) into sums of distinct unit fractions‚Äã EN.WIKIPEDIA.ORG . For instance, it records frac215 = frac110 + frac130‚Äã EN.WIKIPEDIA.ORG . Remarkably, none of these decompositions used more than 4 terms ‚Äì even frac2101 is written as frac1101+frac1202+frac1303+frac1606‚Äã EN.WIKIPEDIA.ORG . After the 2n table, the papyrus gives examples of dividing numbers by 10, using 23 as a key part of the representation. It expresses, for example, frac710 = frac23 + frac130‚Äã EN.WIKIPEDIA.ORG . Here tfrac23 (which is (3-1)3) is used as a summand, showing the Egyptian preference for using (K-1)K forms like 23 to simplify the remainder. (Interestingly, in modern terms frac710 could be written more simply as frac12+frac15, but the Egyptian approach prioritized known unit-fraction tables and conventions.) These historical examples highlight that unit fractions 1K and their complements (K-1)K were building blocks of Egyptian mathematical notation‚Äã EN.WIKIPEDIA.ORG . The use of such fractions had practical motivations: for instance, frac58 = frac12 + frac18 meant that to divide 5 loaves among 8 people, each person could get half a loaf plus an eighth of a loaf‚Äã EN.WIKIPEDIA.ORG . Using unit fractions (and special cases like 23) made it easier to allocate and measure portions in a pre-decimal society. Representing Rational Numbers with Unit Fractions One of the fundamental number-theoretic facts about rational numbers is that any positive rational can be expressed as a sum of distinct unit fractions. In other words, for every fraction fracab (with 0ab) there exists an Egyptian fraction expansion: ùëé ùëè = 1 ùëõ 1","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùëõ 2","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"‚ãØ","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùëõ ùëò , b a ‚Äã  =  n  1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"n  2 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ‚Äã  +‚ãØ+  n  k ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ‚Äã  , where n_1 n_2 dots n_k are positive integers, all different. This was implicitly known to the Egyptians and was formally proven in modern terms by Fibonacci (Leonardo of Pisa). In his 1202 book Liber Abaci, Fibonacci described methods to convert any rational number into a sum of unit fractions‚Äã EN.WIKIPEDIA.ORG . One such method is the greedy algorithm: at each step, take the largest unit fraction not exceeding the remaining fraction. This algorithm (often called Fibonacci‚Äôs algorithm) will terminate with an Egyptian fraction representation‚Äã EN.WIKIPEDIA.ORG ‚Äã EN.WIKIPEDIA.ORG . For example, to expand frac45, the greedy method picks the largest unit fraction le 45, which is 12. Subtracting, 45 - 12 = 310. The largest unit fraction le 310 is 14. Subtracting, 310 - 14 = 120. Thus frac45 = frac12 + frac14 + frac120, an Egyptian fraction expansion‚Äã R-KNOTT.SURREY.AC.UK . (In fact, frac45 can be written more succinctly as frac12+frac15+frac110‚Äã R-KNOTT.SURREY.AC.UK  ‚Äì Egyptian fractions are not unique, and there are often many valid representations.) It is now a well-known theorem that every rational number has infinitely many Egyptian fraction representations‚Äã R-KNOTT.SURREY.AC.UK . Once you find one representation, you can generate more by an identity like 1 = frac12+frac13+frac16 (which is itself an Egyptian fraction)‚Äã R-KNOTT.SURREY.AC.UK : for example, substituting 1 = frac12+frac13+frac16 into any unit fraction frac1m yields frac1m = frac12m + frac13m + frac16m, introducing more terms but still all unit fractions‚Äã R-KNOTT.SURREY.AC.UK . This shows in principle that each rational number has infinitely many expansions‚Äã R-KNOTT.SURREY.AC.UK . Two simple identities involving our specific forms 1K and (K-1)K are worth noting. First, for any nge 2: Two-term expansion for 1n: displaystyle frac1n = frac1n+1 + frac1n(n+1). This identity can be verified by finding a common denominator: frac1n+1 + frac1n(n+1) = fracnn(n+1) + frac1n(n+1) = fracn+1n(n+1) = frac1n. For example, frac14 = frac15 + frac120, and frac110 = frac111 + frac1110. This provides a quick way to split any unit fraction into a sum of two smaller unit fractions. Second, from the earlier mentioned Egyptian identity for 1, we have: Three-term expansion for 1n: displaystyle frac1n = frac12n + frac13n + frac16n. This works because frac12n+frac13n+frac16n = frac3+2+16n = frac66n = frac1n. For example, frac17 = frac114+frac121+frac142. Interestingly, this shows that any single unit fraction 1K can be represented as a sum of three smaller unit fractions. The denominators (2K3K6K) in this formula are the first three positive divisors of 6K, and indeed 6 is a perfect number (equal to the sum of its divisors 1+2+3), which is why the numerators added up neatly to produce the identity‚Äã R-KNOTT.SURREY.AC.UK . The complements (K-1)K can also be expressed as Egyptian fractions. In fact, the Egyptians themselves treated some of these as special cases (23 and 34 they left as is‚Äã EN.WIKIPEDIA.ORG , but others like 45 56, etc., they would break down). As a general strategy, one can use the above identities to derive expansions for (K-1)K = 1 - frac1K. For example, using the two-term expansion of 1K, we get:  ùêæ ‚àí 1 ùêæ = 1 ‚àí 1 ùêæ = 1 ‚àí ( 1 ùêæ","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùêæ ( ùêæ","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ) ) = ùêæ ùêæ ‚àí 1 ùêæ","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ‚àí 1 ùêæ ( ùêæ","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ) . K K‚àí1 ‚Äã  =1‚àí  K 1 ‚Äã  =1‚àí(  K+1 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"K(K+1) 1 ‚Äã  )=  K K ‚Äã  ‚àí  K+1 1 ‚Äã  ‚àí  K(K+1) 1 ‚Äã  . Now fracKK = 1 can itself be written as an Egyptian fraction (for instance 1 = frac12+frac13+frac16 as given, or any other), so by substituting such an expansion for the 1 on the right-hand side, we can obtain an Egyptian fraction for (K-1)K. There isn‚Äôt a single canonical formula for all (K-1)K, but we can illustrate with a few examples: frac23 = frac12 + frac16 (a classic from the Rhind Papyrus)‚Äã R-KNOTT.SURREY.AC.UK . frac34 = frac12 + frac14 (trivial, since 34 already has denominator 4 as one term). frac45 = frac12 + frac15 + frac110 (one of several possibilities‚Äã R-KNOTT.SURREY.AC.UK ). frac67 = frac12 + frac13 + frac142 is one expansion (since 67 = 1 - 17 and we used the three-term expansion for 17 here). In general, representing (K-1)K may take two or more unit fractions depending on K. The ‚Äúgreedy algorithm‚Äù will always find some expansion. For instance, if we apply it to (K-1)K: the first term it picks is 12 (because (K-1)K  1 but is  12 for K2). After subtracting 12, the remainder is (K-1)K - 12 = (2K- (K-1))2K = (K+1)2K = frac12 + frac12K. So one gets (K-1)K = 12 + 12K. If K=3, this gives 23 = 12 + 16 as above; if K=5, it gives 45 = 12 + 110 (but we‚Äôd still have 45 - (12+110) = 15 left over, so actually the greedy algorithm would then add 15 to finish the job). In any case, the key takeaway is that 1K and 1 - 1K are not just reciprocals and complements in the trivial sense, but also act as fundamental pieces that can generate other rational numbers through Egyptian expansions. This is why historically they were tabulated and studied. Patterns in Modular Arithmetic and Repeating Decimals Unit fractions have a natural connection to modular arithmetic, especially when we consider their decimal (or other base) expansions. If K is coprime to 10, the decimal expansion of 1K will be repeating (non-terminating), and its repetend (the repeating block of digits) is intimately related to the multiplicative order of 10 modulo K. In fact, the length of the repeating cycle of 1K is the smallest positive integer d such that 10^d equiv 1 pmodK. For example, 17 = 0overline142857 has a repetend of length 6, and indeed 10^6 = 1000000 equiv 1 pmod7. The repeating digits 142857 are not random; they form what is known as a cyclic number. Multiplying 142857 by any number from 2 through 6 permutes its digits (e.g. 142857 times 2 = 285714), reflecting the fact that 27 37  67 produce cyclic permutations of the same repetend. In particular, frac67 = 0overline857142, which is exactly the ‚Äúcomplement‚Äù of 0overline142857 in the sense that 0overline142857 + 0overline857142 = 0overline999999 = 0999999ldots = 1. Generally, for a denominator K (coprime to the base), 1K and (K-1)K have repeating decimals that are complements of each other: digit by digit, they sum to 9 (in base 10). Another simple example: 13 = 0overline3 and 23 = 0overline6; indeed 3+6=9 in each repeating digit. Similarly, 111 = 0overline09 and 1011 = 0overline90. This pattern arises because (K-1)K = 1 - 1K, so its decimal expansion is the subtraction of 0overlinetext(repetend of 1K) from 1, which yields the 9‚Äôs complement repetend. In modular arithmetic terms, saying 10^d equiv 1 pmodK means K divides 10^d - 1, so 1K = fracA10^d - 1 for some integer A. Here 10^d-1 is a number like 99...9 (d digits of 9), and indeed A will be the integer formed by the repetend digits. For example, 17 = 142857999999 and 67 = 857142999999. This is a clear algebraic relation between a fraction and its repeating pattern. Beyond base-10 patterns, unit fractions also connect to general modular inverses. The number 1K (as a rational number) corresponds to the multiplicative inverse of K in the ring of integers modulo m, if gcd(Km)=1. For instance, 1K pmodp (for p prime not dividing K) is the unique number x such that Kx equiv 1 pmodp. This is essentially Fermat‚Äôs little theorem in action: one can show K^p-1 equiv 1 pmodp, hence K^p-2 equiv K^-1 pmodp, meaning x = K^p-2 is the residue corresponding to 1K. One interesting property here is that the sum of all such modular reciprocals in a prime field has a nice result: for a prime p2,  1","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 2","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 3","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"‚ãØ","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùëù ‚àí 1 ‚â° 0 ( m o d ùëù ) , 1+  2 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"3 1 ‚Äã  +‚ãØ+  p‚àí1 1 ‚Äã  ‚â°0(modp), when interpreted modulo p. This is because the set 1^-12^-1dots(p-1)^-1 is just a permutation of 12dotsp-1 modulo p. For example, mod 7: 1+12+13+14+15+16 equiv 1+4+5+2+3+6 = 21 equiv 0 pmod7. A far deeper result along these lines is Wolstenholme‚Äôs theorem (1862), which states that for any prime p3, the numerator of 1 + frac12 + cdots + frac1p-1 (when written in lowest terms) is divisible by p^2. This implies a congruence like 1 + frac12 + cdots + frac1p-1 equiv 0 pmodp^2 in a certain well-defined sense. Although not directly about 1K vs (K-1)K, Wolstenholme‚Äôs theorem underscores the special role of unit fractions summing up in modular arithmetic contexts. In summary, the forms 1K and (K-1)K show up in base-dependent patterns (like repeating decimals) and base-independent congruences (like properties of harmonic sums mod p). The complement pair 1K and (K-1)K often exhibit symmetry: one might call (K-1)K the ‚Äú9‚Äôs complement‚Äù of 1K in decimal, or in any base the analogous complement to the full reptend. Diophantine Equations and Egyptian Fraction Problems Expressions involving sums of unit fractions naturally lead to Diophantine equations. A classic example is the equation:  1 ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùë¶ = 1 ùëõ , x 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"y 1 ‚Äã  =  n 1 ‚Äã  , with xyn positive integers. Solving this is equivalent to finding an Egyptian fraction representation of 1n with two terms. Clearing denominators gives xy as a multiple of n:  1 ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùë¶ = 1 ùëõ ‚ÄÖ‚Ää ‚ü∫ ‚ÄÖ‚Ää ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"ùë¶ ùë• ùë¶ = 1 ùëõ ‚ÄÖ‚Ää ‚ü∫ ‚ÄÖ‚Ää ùë• ùë¶ = ùëõ ( ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"ùë¶ ) . x 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"y 1 ‚Äã  =  n 1 ‚Äã  ‚ü∫  xy x+y ‚Äã  =  n 1 ‚Äã  ‚ü∫xy=n(x+y). Rearrange to xy - nx - ny = 0 or (x-n)(y-n) = n^2. Thus solutions correspond to pairs of divisors of n^2. For each divisor d of n^2, one can set x-n = d and y-n = fracn^2d, yielding x = d+n and y = fracn^2d + n. This describes all solutions in positive integers. For example, with n=4: (x-4)(y-4)=16. The divisors of 16 give solutions like x-4=1 y-4=16 (so x=5 y=20) corresponding to 15+120=14; or x-4=2 y-4=8 (so x=6y=12) giving 16+112=14; or x-4=4y-4=4 (x=y=8) giving 18+18=14. That last solution uses a repeated unit fraction, which Egyptians would not allow, but mathematically it‚Äôs a valid solution of the equation. We see there are infinitely many representations of frac14 if we allowed repetition, but with the distinctness restriction we have finitely many (in this case two: 15+120 and 16+112) because (xy) and (yx) are considered the same representation for Egyptian fractions. This kind of analysis can be extended to equations with more terms, but it becomes much more complex. One famous problem in this vein is the Erd≈ës‚ÄìStraus conjecture (1948), which focuses on representations of frac4n as a sum of three unit fractions. The conjecture asserts that for every integer nge 2, there exist positive integers xyz such that:  4 ùëõ = 1 ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùë¶","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùëß . n 4 ‚Äã  =  x 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"y 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"z 1 ‚Äã  . In other words, frac4n has an Egyptian fraction expansion of length 3 (not necessarily with distinct denominators, though one can often make them distinct). Despite extensive effort, this conjecture remains unproven in full generality ‚Äì it is one of the longest-standing open problems about Egyptian fractions. It has been verified by computer for very large n (all n  10^17, as well as ‚Äúalmost all‚Äù n beyond that range)‚Äã EN.WIKIPEDIA.ORG , but a general proof is unknown. The conjecture is interesting because frac4n is (n-4)n plus a bit more complexity; why the numerator 4? It appears that 4 is the smallest integer where the property of always having a 3-term expansion might be hard to guarantee ‚Äì for frac3n, it‚Äôs known to be always possible with at most 3 terms, as we‚Äôll discuss next. Erd≈ës and Straus allowing repeated denominators means they considered solutions to 4n = 1x+1y+1z in positive integers without the distinctness condition (one could have x=y for instance). However, any solution with a repeat can be transformed into a solution with distinct terms (usually with more terms) by a transformation akin to the one by Takenouchi (1921)‚Äã EN.WIKIPEDIA.ORG . Empirical evidence strongly suggests Erd≈ës‚ÄìStraus is true ‚Äì no counterexample has been found up to very large n‚Äã EN.WIKIPEDIA.ORG  ‚Äì but it exemplifies how a simple question about unit fractions leads to deep difficulties. What about frac3n or other numerators? If n is a multiple of 3, frac3n is itself a unit fraction (=1(n3)), so the interesting cases are when 3nmid n. In 2000, Timothy Hagedorn proved that if n is not divisible by 3 and is odd, then frac3n can always be written as a sum of three distinct odd unit fractions‚Äã R-KNOTT.SURREY.AC.UK . For example, frac35 = frac12 + frac15 + frac110 (here one denominator is even, 10, so not all odd in this representation; Hagedorn‚Äôs theorem would guarantee a representation like frac35 = frac13 + frac14 + frac160 which uses only odd denominators except the 4‚Ä¶ perhaps a better example: frac37 = frac13 + frac111 + frac1231 uses odd denominators 3,11,231). If n is even and not a multiple of 3, frac3n also appears always to have a 3-term expansion (often even a 2-term one, e.g. frac310 = frac14+frac120). In fact, it‚Äôs known that every frac3n has a three-term expansion (with the possible exception of some even n that are powers of 2, which trivially don‚Äôt since frac32^k reduces to frac32^k and needs at least 3 terms). The case for frac5n and others grows progressively harder; there is no known simple criterion like the Erd≈ës‚ÄìStraus conjecture for 5, but computations suggest frac5n often needs at most 4 terms. Research continues into these kinds of problems, and they blend techniques from number theory, algebra, and computational search. Another intriguing result in this domain was the Erd≈ës‚ÄìGraham conjecture (proposed in 1980 by Paul Erd≈ës and Ronald Graham), which was solved in 2003. This was not about a single fraction but about partitioning the integers. It stated that if the positive integers greater than 1 are arbitrarily partitioned into finitely many subsets, one of those subsets will contain an ‚ÄúEgyptian fraction‚Äù sum that equals 1‚Äã EN.WIKIPEDIA.ORG . In plain terms: no matter how you color the integers in a fixed number of colors, you can always find a monochromatic set of numbers d_1dotsd_k such that frac1d_1+cdots+frac1d_k=1. This was proved by Ernie Croot in 2003‚Äã EN.WIKIPEDIA.ORG , confirming a deep fact about unit fractions summing to 1. Notice the sum to 1 can be seen as a special case of the complement idea: summing to 1 means you‚Äôve perfectly expressed 1 (which is NN for any N) as an Egyptian fraction. Indeed, expressing 1 itself as an Egyptian fraction has a tie to number theory: a number N is perfect if 1 + frac12 + cdots + frac1N-1 = 1 when restricting the sum to divisors of N. For example, 6 is perfect because 6 = 1+2+3, which yields 1 = 12 + 13 + 16. 28 is perfect (divisors 1+2+4+7+14=28) giving 1 = 12+14+17+114+128. More generally, primary pseudoperfect numbers are those that allow an Egyptian fraction of 1 that includes the number itself in the denominators. An example is 1806, which has the property 1806 = 2 times 3 times 7 times 43 divides something and indeed 1 = 12 + 13 + 17 + 143 + 11806‚Äã EN.WIKIPEDIA.ORG . These esoteric patterns show how unit fractions intersect with the theory of divisors and special integers. Finally, a word on computational complexity: finding an Egyptian fraction representation (without additional constraints) is easy via the greedy algorithm, but finding one that minimizes the number of terms or the largest denominator is much harder. No efficient algorithm is known to minimize the number of terms; the search space seems to grow quickly, and it‚Äôs suspected that these minimization problems might be NP-hard (though it remains unproven)‚Äã EN.WIKIPEDIA.ORG . The Egyptian fraction problem has many open questions: Are there efficient algorithms to find expansions with, say, the least maximum denominator? How few terms are needed in general to represent any ab (a conjecture by Erd≈ës posited O(log b) terms always suffice; tighter conjectures say maybe O(loglog b) terms are enough‚Äã EN.WIKIPEDIA.ORG )? Such problems remain active areas of research, bridging number theory and computer science. Conclusion The simple fractions 1K and (K-1)K serve as fundamental building blocks in number theory and its applications. From ancient times, they were the basis of representing all rational numbers as sums of unit fractions ‚Äì a practice that, while no longer used for practical arithmetic, has inspired deep theoretical questions. We‚Äôve seen that every rational number can be composed from unit fractions, often starting with a term like 1K or (K-1)K to approximate the target and then refining the remainder. These fractions show elegant patterns: Egyptian fraction identities, complementary repeating decimals, and modular relationships. They also lead to challenging Diophantine equations: finding integers xyzdots such that fracab = frac1x+frac1y+cdots is a classical problem with many unsolved cases (like the Erd≈ës‚ÄìStraus conjecture for 4n‚Äã EN.WIKIPEDIA.ORG ). On the other hand, much progress has been made ‚Äì for instance, every fraction with odd denominator has an expansion using odd unit fractions‚Äã EN.WIKIPEDIA.ORG , and every large enough integer can be partitioned to yield an Egyptian sum for 1‚Äã EN.WIKIPEDIA.ORG . In a way, exploring 1K and (K-1)K is exploring how the number 1 can be broken into harmonious parts. The ancient Egyptians might have seen it as practical arithmetic and fair division, while modern mathematicians see combinatorial structures and infinite possibilities. These tiny fractions connect the very concrete (sharing 5 pizzas among 8 people) to the very abstract (coloring integers or analyzing prime divisors). The fascination of unit fractions endures ‚Äì a testament to how even the simplest components of arithmetic hide endless patterns and puzzles in their reciprocals. Sources: Historical details from the Rhind Papyrus and Egyptian fraction usage‚Äã EN.WIKIPEDIA.ORG ‚Äã EN.WIKIPEDIA.ORG ‚Äã EN.WIKIPEDIA.ORG ; Fibonacci‚Äôs greedy algorithm and identities‚Äã EN.WIKIPEDIA.ORG ‚Äã R-KNOTT.SURREY.AC.UK ; examples of expansions‚Äã R-KNOTT.SURREY.AC.UK ‚Äã R-KNOTT.SURREY.AC.UK ; modern results on Egyptian fractions and conjectures‚Äã R-KNOTT.SURREY.AC.UK ‚Äã EN.WIKIPEDIA.ORG ‚Äã EN.WIKIPEDIA.ORG ‚Äã EN.WIKIPEDIA.ORG . Patterns in Modular Arithmetic and Repeating Decimals Unit fractions have a natural connection to modular arithmetic, especially when we consider their decimal (or other base) expansions. If K is coprime to 10, the decimal expansion of 1K will be repeating (non-terminating), and its repetend (the repeating block of digits) is intimately related to the multiplicative order of 10 modulo K. In fact, the length of the repeating cycle of 1K is the smallest positive integer d such that 10^d equiv 1 pmodK. For example, 17 = 0overline142857 has a repetend of length 6, and indeed 10^6 = 1000000 equiv 1 pmod7. The repeating digits 142857 are not random; they form what is known as a cyclic number. Multiplying 142857 by any number from 2 through 6 permutes its digits (e.g. 142857 times 2 = 285714), reflecting the fact that 27 37  67 produce cyclic permutations of the same repetend. In particular, frac67 = 0overline857142, which is exactly the ‚Äúcomplement‚Äù of 0overline142857 in the sense that 0overline142857 + 0overline857142 = 0overline999999 = 0999999ldots = 1. Generally, for a denominator K (coprime to the base), 1K and (K-1)K have repeating decimals that are complements of each other: digit by digit, they sum to 9 (in base 10). Another simple example: 13 = 0overline3 and 23 = 0overline6; indeed 3+6=9 in each repeating digit. Similarly, 111 = 0overline09 and 1011 = 0overline90. This pattern arises because (K-1)K = 1 - 1K, so its decimal expansion is the subtraction of 0overlinetext(repetend of 1K) from 1, which yields the 9‚Äôs complement repetend. In modular arithmetic terms, saying 10^d equiv 1 pmodK means K divides 10^d - 1, so 1K = fracA10^d - 1 for some integer A. Here 10^d-1 is a number like 99...9 (d digits of 9), and indeed A will be the integer formed by the repetend digits. For example, 17 = 142857999999 and 67 = 857142999999. This is a clear algebraic relation between a fraction and its repeating pattern. Beyond base-10 patterns, unit fractions also connect to general modular inverses. The number 1K (as a rational number) corresponds to the multiplicative inverse of K in the ring of integers modulo m, if gcd(Km)=1. For instance, 1K pmodp (for p prime not dividing K) is the unique number x such that Kx equiv 1 pmodp. This is essentially Fermat‚Äôs little theorem in action: one can show K^p-1 equiv 1 pmodp, hence K^p-2 equiv K^-1 pmodp, meaning x = K^p-2 is the residue corresponding to 1K. One interesting property here is that the sum of all such modular reciprocals in a prime field has a nice result: for a prime p2,  1","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 2","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 3","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"‚ãØ","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùëù ‚àí 1 ‚â° 0 ( m o d ùëù ) , 1+  2 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"3 1 ‚Äã  +‚ãØ+  p‚àí1 1 ‚Äã  ‚â°0(modp), when interpreted modulo p. This is because the set 1^-12^-1dots(p-1)^-1 is just a permutation of 12dotsp-1 modulo p. For example, mod 7: 1+12+13+14+15+16 equiv 1+4+5+2+3+6 = 21 equiv 0 pmod7. A far deeper result along these lines is Wolstenholme‚Äôs theorem (1862), which states that for any prime p3, the numerator of 1 + frac12 + cdots + frac1p-1 (when written in lowest terms) is divisible by p^2. This implies a congruence like 1 + frac12 + cdots + frac1p-1 equiv 0 pmodp^2 in a certain well-defined sense. Although not directly about 1K vs (K-1)K, Wolstenholme‚Äôs theorem underscores the special role of unit fractions summing up in modular arithmetic contexts. In summary, the forms 1K and (K-1)K show up in base-dependent patterns (like repeating decimals) and base-independent congruences (like properties of harmonic sums mod p). The complement pair 1K and (K-1)K often exhibit symmetry: one might call (K-1)K the ‚Äú9‚Äôs complement‚Äù of 1K in decimal, or in any base the analogous complement to the full reptend. Diophantine Equations and Egyptian Fraction Problems Expressions involving sums of unit fractions naturally lead to Diophantine equations. A classic example is the equation:  1 ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùë¶ = 1 ùëõ , x 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"y 1 ‚Äã  =  n 1 ‚Äã  , with xyn positive integers. Solving this is equivalent to finding an Egyptian fraction representation of 1n with two terms. Clearing denominators gives xy as a multiple of n:  1 ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùë¶ = 1 ùëõ ‚ÄÖ‚Ää ‚ü∫ ‚ÄÖ‚Ää ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"ùë¶ ùë• ùë¶ = 1 ùëõ ‚ÄÖ‚Ää ‚ü∫ ‚ÄÖ‚Ää ùë• ùë¶ = ùëõ ( ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"ùë¶ ) . x 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"y 1 ‚Äã  =  n 1 ‚Äã  ‚ü∫  xy x+y ‚Äã  =  n 1 ‚Äã  ‚ü∫xy=n(x+y). Rearrange to xy - nx - ny = 0 or (x-n)(y-n) = n^2. Thus solutions correspond to pairs of divisors of n^2. For each divisor d of n^2, one can set x-n = d and y-n = fracn^2d, yielding x = d+n and y = fracn^2d + n. This describes all solutions in positive integers. For example, with n=4: (x-4)(y-4)=16. The divisors of 16 give solutions like x-4=1 y-4=16 (so x=5 y=20) corresponding to 15+120=14; or x-4=2 y-4=8 (so x=6y=12) giving 16+112=14; or x-4=4y-4=4 (x=y=8) giving 18+18=14. That last solution uses a repeated unit fraction, which Egyptians would not allow, but mathematically it‚Äôs a valid solution of the equation. We see there are infinitely many representations of frac14 if we allowed repetition, but with the distinctness restriction we have finitely many (in this case two: 15+120 and 16+112) because (xy) and (yx) are considered the same representation for Egyptian fractions. This kind of analysis can be extended to equations with more terms, but it becomes much more complex. One famous problem in this vein is the Erd≈ës‚ÄìStraus conjecture (1948), which focuses on representations of frac4n as a sum of three unit fractions. The conjecture asserts that for every integer nge 2, there exist positive integers xyz such that:  4 ùëõ = 1 ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùë¶","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùëß . n 4 ‚Äã  =  x 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"y 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"z 1 ‚Äã  . In other words, frac4n has an Egyptian fraction expansion of length 3 (not necessarily with distinct denominators, though one can often make them distinct). Despite extensive effort, this conjecture remains unproven in full generality ‚Äì it is one of the longest-standing open problems about Egyptian fractions. It has been verified by computer for very large n (all n  10^17, as well as ‚Äúalmost all‚Äù n beyond that range)‚Äã EN.WIKIPEDIA.ORG , but a general proof is unknown. The conjecture is interesting because frac4n is (n-4)n plus a bit more complexity; why the numerator 4? It appears that 4 is the smallest integer where the property of always having a 3-term expansion might be hard to guarantee ‚Äì for frac3n, it‚Äôs known to be always possible with at most 3 terms, as we‚Äôll discuss next. Erd≈ës and Straus allowing repeated denominators means they considered solutions to 4n = 1x+1y+1z in positive integers without the distinctness condition (one could have x=y for instance). However, any solution with a repeat can be transformed into a solution with distinct terms (usually with more terms) by a transformation akin to the one by Takenouchi (1921)‚Äã EN.WIKIPEDIA.ORG . Empirical evidence strongly suggests Erd≈ës‚ÄìStraus is true ‚Äì no counterexample has been found up to very large n‚Äã EN.WIKIPEDIA.ORG  ‚Äì but it exemplifies how a simple question about unit fractions leads to deep difficulties. What about frac3n or other numerators? If n is a multiple of 3, frac3n is itself a unit fraction (=1(n3)), so the interesting cases are when 3nmid n. In 2000, Timothy Hagedorn proved that if n is not divisible by 3 and is odd, then frac3n can always be written as a sum of three distinct odd unit fractions‚Äã R-KNOTT.SURREY.AC.UK . For example, frac35 = frac12 + frac15 + frac110 (here one denominator is even, 10, so not all odd in this representation; Hagedorn‚Äôs theorem would guarantee a representation like frac35 = frac13 + frac14 + frac160 which uses only odd denominators except the 4‚Ä¶ perhaps a better example: frac37 = frac13 + frac111 + frac1231 uses odd denominators 3,11,231). If n is even and not a multiple of 3, frac3n also appears always to have a 3-term expansion (often even a 2-term one, e.g. frac310 = frac14+frac120). In fact, it‚Äôs known that every frac3n has a three-term expansion (with the possible exception of some even n that are powers of 2, which trivially don‚Äôt since frac32^k reduces to frac32^k and needs at least 3 terms). The case for frac5n and others grows progressively harder; there is no known simple criterion like the Erd≈ës‚ÄìStraus conjecture for 5, but computations suggest frac5n often needs at most 4 terms. Research continues into these kinds of problems, and they blend techniques from number theory, algebra, and computational search. Another intriguing result in this domain was the Erd≈ës‚ÄìGraham conjecture (proposed in 1980 by Paul Erd≈ës and Ronald Graham), which was solved in 2003. This was not about a single fraction but about partitioning the integers. It stated that if the positive integers greater than 1 are arbitrarily partitioned into finitely many subsets, one of those subsets will contain an ‚ÄúEgyptian fraction‚Äù sum that equals 1‚Äã EN.WIKIPEDIA.ORG . In plain terms: no matter how you color the integers in a fixed number of colors, you can always find a monochromatic set of numbers d_1dotsd_k such that frac1d_1+cdots+frac1d_k=1. This was proved by Ernie Croot in 2003‚Äã EN.WIKIPEDIA.ORG , confirming a deep fact about unit fractions summing to 1. Notice the sum to 1 can be seen as a special case of the complement idea: summing to 1 means you‚Äôve perfectly expressed 1 (which is NN for any N) as an Egyptian fraction. Indeed, expressing 1 itself as an Egyptian fraction has a tie to number theory: a number N is perfect if 1 + frac12 + cdots + frac1N-1 = 1 when restricting the sum to divisors of N. For example, 6 is perfect because 6 = 1+2+3, which yields 1 = 12 + 13 + 16. 28 is perfect (divisors 1+2+4+7+14=28) giving 1 = 12+14+17+114+128. More generally, primary pseudoperfect numbers are those that allow an Egyptian fraction of 1 that includes the number itself in the denominators. An example is 1806, which has the property 1806 = 2 times 3 times 7 times 43 divides something and indeed 1 = 12 + 13 + 17 + 143 + 11806‚Äã EN.WIKIPEDIA.ORG . These esoteric patterns show how unit fractions intersect with the theory of divisors and special integers. Finally, a word on computational complexity: finding an Egyptian fraction representation (without additional constraints) is easy via the greedy algorithm, but finding one that minimizes the number of terms or the largest denominator is much harder. No efficient algorithm is known to minimize the number of terms; the search space seems to grow quickly, and it‚Äôs suspected that these minimization problems might be NP-hard (though it remains unproven)‚Äã EN.WIKIPEDIA.ORG . The Egyptian fraction problem has many open questions: Are there efficient algorithms to find expansions with, say, the least maximum denominator? How few terms are needed in general to represent any ab (a conjecture by Erd≈ës posited O(log b) terms always suffice; tighter conjectures say maybe O(loglog b) terms are enough‚Äã EN.WIKIPEDIA.ORG )? Such problems remain active areas of research, bridging number theory and computer science. Conclusion The simple fractions 1K and (K-1)K serve as fundamental building blocks in number theory and its applications. From ancient times, they were the basis of representing all rational numbers as sums of unit fractions ‚Äì a practice that, while no longer used for practical arithmetic, has inspired deep theoretical questions. We‚Äôve seen that every rational number can be composed from unit fractions, often starting with a term like 1K or (K-1)K to approximate the target and then refining the remainder. These fractions show elegant patterns: Egyptian fraction identities, complementary repeating decimals, and modular relationships. They also lead to challenging Diophantine equations: finding integers xyzdots such that fracab = frac1x+frac1y+cdots is a classical problem with many unsolved cases (like the Erd≈ës‚ÄìStraus conjecture for 4n‚Äã EN.WIKIPEDIA.ORG ). On the other hand, much progress has been made ‚Äì for instance, every fraction with odd denominator has an expansion using odd unit fractions‚Äã EN.WIKIPEDIA.ORG , and every large enough integer can be partitioned to yield an Egyptian sum for 1‚Äã EN.WIKIPEDIA.ORG . In a way, exploring 1K and (K-1)K is exploring how the number 1 can be broken into harmonious parts. The ancient Egyptians might have seen it as practical arithmetic and fair division, while modern mathematicians see combinatorial structures and infinite possibilities. These tiny fractions connect the very concrete (sharing 5 pizzas among 8 people) to the very abstract (coloring integers or analyzing prime divisors). The fascination of unit fractions endures ‚Äì a testament to how even the simplest components of arithmetic hide endless patterns and puzzles in their reciprocals.","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"glossary/","page":"-","title":"-","text":"unit fraction     A fraction with a numerator of 1. For example, 1/2, 1/3, and 1/4 are unit fractions.     [ \"The Rational Number n/p  as a sum of two unit fractions\"       Konstantine Zelator, 2012-Feb-29. https://arxiv.org/pdf/1203.0018     ]      ]","category":"page"},{"location":"glossary/","page":"-","title":"-","text":"unit fraction and complementary unit fraction     A unit fraction is a positive rational number 1/K with numerator 1 and denominator integer K>0.     The complement (complementary unit fraction) is 1 - 1/K == (K - 1) / K.","category":"page"},{"location":"glossary/","page":"-","title":"-","text":"1/K + (K - 1)/K == (1 + (K - 1)) / K == (K + 1 - 1) / K == K/K == 1     [ \"The Rational Number n/p  as a sum of two unit fractions\"       Konstantine Zelator, 2012-Feb-29. https://arxiv.org/pdf/1203.0018","category":"page"},{"location":"glossary/","page":"-","title":"-","text":"0/K, 1/K, 2/K, 3/K, ... (K-2)/K, (K-1)/K, K/K      ^ unit fraction              ^ complementary unit fraction      ^ Qunit fraction             ^ Qcomplement","category":"page"},{"location":"glossary/","page":"-","title":"-","text":"0/1 < Qunit < ... <  Qcomplement  < 1/1","category":"page"},{"location":"glossary/","page":"-","title":"-","text":"subnormalmin(nFracBits(T)) == Qunit(nFracBits(T)) subnormalmax(nFracBits(T)) == Qcomplement(nFracBits(T))","category":"page"},{"location":"glossary/","page":"-","title":"-","text":"","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"(generated by Claude Sonnet 4 2025-06-08T10:17Z)","category":"page"},{"location":"ai_abstract_float/#AbstractAIFloat-Documentation","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"A comprehensive floating-point type system for AI applications with configurable precision and special value handling.","category":"page"},{"location":"ai_abstract_float/#Table-of-Contents","page":"AbstractAIFloat Documentation","title":"Table of Contents","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"Overview\nType Hierarchy\nQuick Start\nAPI Reference\nExamples\nAdvanced Usage\nPerformance Considerations","category":"page"},{"location":"ai_abstract_float/#Overview","page":"AbstractAIFloat Documentation","title":"Overview","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"The AbstractAIFloat system provides a flexible framework for defining custom floating-point types optimized for AI and machine learning applications. It supports:","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"Configurable bit widths and significand precision\nSigned and unsigned variants\nFinite and extended (with infinity) representations\nComprehensive introspection functions for type properties\nValue sequence generation for systematic exploration of the number space","category":"page"},{"location":"ai_abstract_float/#Key-Features","page":"AbstractAIFloat Documentation","title":"Key Features","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"üéØ Precision Control: Customize total bits and significand bits independently\nüîÑ Sign Variants: Support both signed and unsigned number representations  \n‚ôæÔ∏è Infinity Handling: Choose finite-only or extended (with ¬±‚àû) representations\nüìä Rich Metadata: Extensive functions to query type properties and counts\nüé≤ Value Generation: Built-in functions to generate complete value sequences","category":"page"},{"location":"ai_abstract_float/#Type-Hierarchy","page":"AbstractAIFloat Documentation","title":"Type Hierarchy","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"AbstractAIFloat{Bits, SigBits, IsSigned} <: AbstractFloat\n‚îú‚îÄ‚îÄ AbsSignedFloat{Bits, SigBits}   # IsSigned = true\n‚îÇ   ‚îú‚îÄ‚îÄ AbsSignedFiniteFloat{Bits, SigBits}     # No infinities\n‚îÇ   ‚îî‚îÄ‚îÄ AbsSignedExtendedFloat{Bits, SigBits}   # With ¬±‚àû\n‚îî‚îÄ‚îÄ AbsUnsignedFloat{Bits, SigBits} # IsSigned = false  \n    ‚îú‚îÄ‚îÄ AbsUnsignedFiniteFloat{Bits, SigBits}   # No infinities\n    ‚îî‚îÄ‚îÄ AbsUnsignedExtendedFloat{Bits, SigBits} # With +‚àû only","category":"page"},{"location":"ai_abstract_float/#Type-Parameters","page":"AbstractAIFloat Documentation","title":"Type Parameters","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"Bits: Total number of bits in the representation (e.g., 8, 16, 32)\nSigBits: Number of significand bits including implicit leading bit\nIsSigned: Boolean indicating if the type supports negative values","category":"page"},{"location":"ai_abstract_float/#Quick-Start","page":"AbstractAIFloat Documentation","title":"Quick Start","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"# Define concrete types by subtyping the abstracts\nstruct MyFloat8_4 <: AbsSignedFiniteFloat{8, 4} end\nstruct MyUFloat8_4 <: AbsUnsignedFiniteFloat{8, 4} end\n\n# Query basic properties\nnBits(MyFloat8_4)     # 8\nnSigBits(MyFloat8_4)  # 4  \nnFracBits(MyFloat8_4) # 3\nis_signed(MyFloat8_4) # true\nis_finite(MyFloat8_4) # true\n\n# Count different value types\nnValues(MyFloat8_4)         # 256 (total possible values)\nnFiniteValues(MyFloat8_4)   # 255 (excluding NaN)\nnPositiveValues(MyFloat8_4) # 127 (positive finite values)\n\n# Generate value sequences\nvalues = value_sequence(MyFloat8_4)  # Complete sequence of representable values","category":"page"},{"location":"ai_abstract_float/#API-Reference","page":"AbstractAIFloat Documentation","title":"API Reference","text":"","category":"section"},{"location":"ai_abstract_float/#Type-Predicates","page":"AbstractAIFloat Documentation","title":"Type Predicates","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"Functions to determine type characteristics:","category":"page"},{"location":"ai_abstract_float/#is_signed(T)-/-is_unsigned(T)","page":"AbstractAIFloat Documentation","title":"is_signed(T) / is_unsigned(T)","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"is_signed(::Type{T}) where {T<:AbstractAIFloat} ‚Üí Bool\nis_unsigned(::Type{T}) where {T<:AbstractAIFloat} ‚Üí Bool","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"Test whether a type supports negative values.","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"Examples:","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"is_signed(AbsSignedFiniteFloat{8,4})   # true\nis_unsigned(AbsUnsignedFiniteFloat{8,4}) # true","category":"page"},{"location":"ai_abstract_float/#is_finite(T)-/-is_extended(T)","page":"AbstractAIFloat Documentation","title":"is_finite(T) / is_extended(T)","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"is_finite(::Type{T}) where {T<:AbstractAIFloat} ‚Üí Bool  \nis_extended(::Type{T}) where {T<:AbstractAIFloat} ‚Üí Bool","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"Test whether a type includes infinity values.","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"Examples:","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"is_finite(AbsSignedFiniteFloat{8,4})   # true\nis_extended(AbsSignedExtendedFloat{8,4}) # true","category":"page"},{"location":"ai_abstract_float/#Abstract-Type-Predicates","page":"AbstractAIFloat Documentation","title":"Abstract Type Predicates","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"For use with abstract supertypes:","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"isa_signed(@nospecialize(T::Type{<:AbsSignedFloat})) ‚Üí Bool\nisa_unsigned(@nospecialize(T::Type{<:AbsUnsignedFloat})) ‚Üí Bool  \nisa_finite(@nospecialize(T::Type{<:AbsSignedFiniteFloat})) ‚Üí Bool\nisa_extended(@nospecialize(T::Type{<:AbsSignedExtendedFloat})) ‚Üí Bool","category":"page"},{"location":"ai_abstract_float/#Basic-Properties","page":"AbstractAIFloat Documentation","title":"Basic Properties","text":"","category":"section"},{"location":"ai_abstract_float/#Bit-Layout-Functions","page":"AbstractAIFloat Documentation","title":"Bit Layout Functions","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"nBits(T) ‚Üí Int          # Total bits in representation\nnSigBits(T) ‚Üí Int       # Significand bits (including implicit bit)\nnFracBits(T) ‚Üí Int      # Fractional bits (nSigBits - 1)\nnExpBits(T) ‚Üí Int       # Exponent bits","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"Note: Unsigned types get an extra exponent bit since no sign bit is needed.","category":"page"},{"location":"ai_abstract_float/#Value-Counts","page":"AbstractAIFloat Documentation","title":"Value Counts","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"nValues(T) ‚Üí Int                # Total representable values (2^nBits)\nnNumericValues(T) ‚Üí Int         # Non-NaN values  \nnNonzeroNumericValues(T) ‚Üí Int  # Non-NaN, non-zero values","category":"page"},{"location":"ai_abstract_float/#Special-Value-Counts","page":"AbstractAIFloat Documentation","title":"Special Value Counts","text":"","category":"section"},{"location":"ai_abstract_float/#NaN,-Zero,-and-Infinity-Counts","page":"AbstractAIFloat Documentation","title":"NaN, Zero, and Infinity Counts","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"nNaNs(T) ‚Üí Int      # Always 1\nnZeros(T) ‚Üí Int     # Always 1  \nnInfs(T) ‚Üí Int      # 0 for finite, 1 for unsigned extended, 2 for signed extended\nnPosInfs(T) ‚Üí Int   # Positive infinities\nnNegInfs(T) ‚Üí Int   # Negative infinities (0 for unsigned)","category":"page"},{"location":"ai_abstract_float/#Magnitude-and-Sign-Counts","page":"AbstractAIFloat Documentation","title":"Magnitude and Sign Counts","text":"","category":"section"},{"location":"ai_abstract_float/#Magnitude-Functions","page":"AbstractAIFloat Documentation","title":"Magnitude Functions","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"nMagnitudes(T) ‚Üí Int           # Total magnitude values\nnNonzeroMagnitudes(T) ‚Üí Int    # Non-zero magnitude values\nnFiniteMagnitudes(T) ‚Üí Int     # Finite magnitude values","category":"page"},{"location":"ai_abstract_float/#Sign-Specific-Counts","page":"AbstractAIFloat Documentation","title":"Sign-Specific Counts","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"nNonnegValues(T) ‚Üí Int         # Non-negative values (‚â• 0)\nnPositiveValues(T) ‚Üí Int       # Positive values (> 0)  \nnNegativeValues(T) ‚Üí Int       # Negative values (< 0)\nnFinitePositiveValues(T) ‚Üí Int # Finite positive values\nnFiniteNegativeValues(T) ‚Üí Int # Finite negative values","category":"page"},{"location":"ai_abstract_float/#Normal-and-Subnormal-Counts","page":"AbstractAIFloat Documentation","title":"Normal and Subnormal Counts","text":"","category":"section"},{"location":"ai_abstract_float/#Subnormal-(Denormalized)-Values","page":"AbstractAIFloat Documentation","title":"Subnormal (Denormalized) Values","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"nPrenormalMagnitudes(T) ‚Üí Int  # Magnitudes in subnormal range (including zero)\nnSubnormalMagnitudes(T) ‚Üí Int  # Non-zero subnormal magnitudes\nnPrenormalValues(T) ‚Üí Int      # Subnormal values (including zero)\nnSubnormalValues(T) ‚Üí Int      # Non-zero subnormal values","category":"page"},{"location":"ai_abstract_float/#Normal-Values","page":"AbstractAIFloat Documentation","title":"Normal Values","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"nNormalMagnitudes(T) ‚Üí Int        # Normal magnitude values\nnNormalValues(T) ‚Üí Int            # Normal values\nnExtendedNormalMagnitudes(T) ‚Üí Int # Normal + infinity magnitudes\nnExtendedNormalValues(T) ‚Üí Int    # Normal + infinity values","category":"page"},{"location":"ai_abstract_float/#Exponent-System","page":"AbstractAIFloat Documentation","title":"Exponent System","text":"","category":"section"},{"location":"ai_abstract_float/#Exponent-Properties","page":"AbstractAIFloat Documentation","title":"Exponent Properties","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"expBias(T) ‚Üí Int              # Exponent bias\nexpUnbiasedMax(T) ‚Üí Int       # Maximum unbiased exponent\nexpUnbiasedMin(T) ‚Üí Int       # Minimum unbiased exponent  \nexpUnbiasedValues(T) ‚Üí Vector # All unbiased exponent values\nexpMaxValue(T) ‚Üí Float64      # 2^expUnbiasedMax\nexpMinValue(T) ‚Üí Float64      # 2^expUnbiasedMin","category":"page"},{"location":"ai_abstract_float/#Exponent-Counts","page":"AbstractAIFloat Documentation","title":"Exponent Counts","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"nExpValues(T) ‚Üí Int           # Total exponent values (2^nExpBits)\nnNonzeroExpValues(T) ‚Üí Int    # Non-zero exponent values","category":"page"},{"location":"ai_abstract_float/#Significand-Properties","page":"AbstractAIFloat Documentation","title":"Significand Properties","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"nSigMagnitudes(T) ‚Üí Int       # Significand magnitude values (2^nSigBits)\nnNonzeroSigMagnitudes(T) ‚Üí Int # Non-zero significand magnitudes\nnFracMagnitudes(T) ‚Üí Int      # Fractional part values (2^nFracBits)  \nnNonzeroFracMagnitudes(T) ‚Üí Int # Non-zero fractional parts","category":"page"},{"location":"ai_abstract_float/#Value-Generation-Functions","page":"AbstractAIFloat Documentation","title":"Value Generation Functions","text":"","category":"section"},{"location":"ai_abstract_float/#Magnitude-Step-Functions","page":"AbstractAIFloat Documentation","title":"Magnitude Step Functions","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"prenormal_magnitude_steps(T) ‚Üí Vector{Float64}\nnormal_magnitude_steps(T) ‚Üí Vector{Float64}","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"Generate normalized magnitude steps for subnormal and normal ranges.","category":"page"},{"location":"ai_abstract_float/#Foundation-Functions","page":"AbstractAIFloat Documentation","title":"Foundation Functions","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"foundation_extremal_exps(T) ‚Üí Tuple{Int, Int}    # (min_exp, max_exp)\nfoundation_exps(T) ‚Üí UnitRange{Int}              # Range of foundation exponents\nfoundation_magnitudes(T) ‚Üí Vector{Float64}       # Base magnitude values","category":"page"},{"location":"ai_abstract_float/#Complete-Value-Sequences","page":"AbstractAIFloat Documentation","title":"Complete Value Sequences","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"value_sequence(T) ‚Üí Vector{Float64}","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"Generate the complete sequence of representable values for the type, including special values (NaN, ¬±‚àû) in appropriate positions.","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"Behavior by type:","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"Finite types: Last value is NaN\nExtended types: Penultimate value is +‚àû (or +‚àû/-‚àû for signed), last is NaN\nSigned types: Negative values appended, with NaN replacing -0","category":"page"},{"location":"ai_abstract_float/#Utility-Functions","page":"AbstractAIFloat Documentation","title":"Utility Functions","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"two_pow(x::Integer) ‚Üí Float32  # Efficient 2^x computation\nnormal_exp_stride(T) ‚Üí Int     # Stride between exponent groups\nexp_unbiased_magnitude_strides(T) ‚Üí Vector{Int} # Exponent strides for magnitudes\npow2_foundation_exps(T, res) ‚Üí Vector{Float32}  # 2^exponent values","category":"page"},{"location":"ai_abstract_float/#Examples","page":"AbstractAIFloat Documentation","title":"Examples","text":"","category":"section"},{"location":"ai_abstract_float/#Example-1:-8-bit-Signed-Finite-Float-with-4-Significand-Bits","page":"AbstractAIFloat Documentation","title":"Example 1: 8-bit Signed Finite Float with 4 Significand Bits","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"struct Float8_4 <: AbsSignedFiniteFloat{8, 4} end\n\n# Basic properties\n@show nBits(Float8_4)          # 8\n@show nSigBits(Float8_4)       # 4  \n@show nExpBits(Float8_4)       # 4 (8 - 4 = 4)\n@show expBias(Float8_4)        # 8 (2^(8-4-1) = 2^3)\n\n# Value counts\n@show nValues(Float8_4)        # 256 (2^8)\n@show nFiniteValues(Float8_4)  # 255 (no infinities)\n@show nPositiveValues(Float8_4) # 127 (half minus zero)\n@show nNegativeValues(Float8_4) # 127\n\n# Subnormal analysis  \n@show nPrenormalMagnitudes(Float8_4)  # 8 (2^(4-1))\n@show nSubnormalMagnitudes(Float8_4)  # 7 (8-1)\n@show nPrenormalValues(Float8_4)      # 15 (2*8-1)\n\n# Generate all values\nvalues = value_sequence(Float8_4)\nprintln(\"Total values generated: $(length(values))\")\nprintln(\"NaN count: $(count(isnan, values))\")  \nprintln(\"Finite count: $(count(isfinite, values))\")","category":"page"},{"location":"ai_abstract_float/#Example-2:-16-bit-Unsigned-Extended-Float-with-8-Significand-Bits","page":"AbstractAIFloat Documentation","title":"Example 2: 16-bit Unsigned Extended Float with 8 Significand Bits","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"struct UFloat16_8 <: AbsUnsignedExtendedFloat{16, 8} end\n\n# Extended type properties\n@show is_unsigned(UFloat16_8)    # true\n@show is_extended(UFloat16_8)    # true\n@show nInfs(UFloat16_8)          # 1 (+‚àû only)\n@show nPosInfs(UFloat16_8)       # 1\n@show nNegInfs(UFloat16_8)       # 0\n\n# Bit allocation (unsigned gets extra exponent bit)\n@show nExpBits(UFloat16_8)       # 9 (16 - 8 + 1)\n@show expBias(UFloat16_8)        # 256 (2^(16-8))\n\n# Value counts\n@show nFiniteValues(UFloat16_8)  # 65534 (65535 - 1 inf)\n@show nMagnitudes(UFloat16_8)    # 65535 (all non-NaN)\n\n# Generate values  \nvalues = value_sequence(UFloat16_8)\ninf_count = count(isinf, values)\nprintln(\"Infinity values: $inf_count\")","category":"page"},{"location":"ai_abstract_float/#Example-3:-Comparing-Signed-vs-Unsigned-Layouts","page":"AbstractAIFloat Documentation","title":"Example 3: Comparing Signed vs Unsigned Layouts","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"struct SignedFloat{B,S} <: AbsSignedFiniteFloat{B,S} end\nstruct UnsignedFloat{B,S} <: AbsUnsignedFiniteFloat{B,S} end\n\nfunction compare_layouts(bits, sigbits)\n    S = SignedFloat{bits, sigbits}\n    U = UnsignedFloat{bits, sigbits}\n    \n    println(\"Comparing $(bits)-bit floats with $(sigbits) significand bits:\")\n    println(\"                    Signed  Unsigned\")\n    println(\"Exponent bits:      $(nExpBits(S))       $(nExpBits(U))\")\n    println(\"Exponent bias:      $(expBias(S))       $(expBias(U))\")  \n    println(\"Max unbiased exp:   $(expUnbiasedMax(S))       $(expUnbiasedMax(U))\")\n    println(\"Total magnitudes:   $(nMagnitudes(S))     $(nMagnitudes(U))\")\nend\n\ncompare_layouts(8, 4)\n# Output:\n# Comparing 8-bit floats with 4 significand bits:\n#                     Signed  Unsigned  \n# Exponent bits:      4       5\n# Exponent bias:      8       16\n# Max unbiased exp:   7       15\n# Total magnitudes:   128     255","category":"page"},{"location":"ai_abstract_float/#Example-4:-Exploring-Value-Distributions","page":"AbstractAIFloat Documentation","title":"Example 4: Exploring Value Distributions","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"struct TestFloat <: AbsSignedExtendedFloat{10, 5} end\n\nfunction analyze_value_distribution(T)\n    println(\"Value distribution for $(T):\")\n    println(\"Total bits: $(nBits(T)), Significand: $(nSigBits(T))\")\n    println()\n    \n    # Special values\n    println(\"Special values:\")\n    println(\"  NaN: $(nNaNs(T))\")\n    println(\"  Zeros: $(nZeros(T))\")  \n    println(\"  +‚àû: $(nPosInfs(T))\")\n    println(\"  -‚àû: $(nNegInfs(T))\")\n    println()\n    \n    # Normal vs subnormal\n    println(\"Normal/Subnormal breakdown:\")\n    println(\"  Subnormal values: $(nSubnormalValues(T))\")\n    println(\"  Normal values: $(nNormalValues(T))\")\n    println(\"  Extended normal: $(nExtendedNormalValues(T))\")\n    println()\n    \n    # Sign distribution  \n    println(\"Sign distribution:\")\n    println(\"  Positive: $(nPositiveValues(T))\")\n    println(\"  Negative: $(nNegativeValues(T))\")\n    println(\"  Non-negative: $(nNonnegValues(T))\")\n    println()\n    \n    # Verification\n    total = nNaNs(T) + nZeros(T) + nInfs(T) + nSubnormalValues(T) + nNormalValues(T)\n    println(\"Verification: $(total) = $(nValues(T)) ‚úì\")\nend\n\nanalyze_value_distribution(TestFloat)","category":"page"},{"location":"ai_abstract_float/#Advanced-Usage","page":"AbstractAIFloat Documentation","title":"Advanced Usage","text":"","category":"section"},{"location":"ai_abstract_float/#Custom-Value-Sequence-Processing","page":"AbstractAIFloat Documentation","title":"Custom Value Sequence Processing","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"function analyze_value_gaps(T)\n    \"\"\"Analyze gaps between consecutive finite values.\"\"\"\n    values = value_sequence(T)\n    finite_vals = filter(isfinite, values)\n    sort!(finite_vals)\n    \n    gaps = diff(finite_vals)\n    \n    println(\"Value gap analysis for $(T):\")\n    println(\"Min gap: $(minimum(gaps))\")\n    println(\"Max gap: $(maximum(gaps))\")  \n    println(\"Mean gap: $(sum(gaps)/length(gaps))\")\n    \n    # Find largest gaps\n    gap_indices = sortperm(gaps, rev=true)[1:5]\n    println(\"\\nLargest gaps:\")\n    for (i, idx) in enumerate(gap_indices)\n        println(\"  $i. $(gaps[idx]) between $(finite_vals[idx]) and $(finite_vals[idx+1])\")\n    end\nend","category":"page"},{"location":"ai_abstract_float/#Type-Generic-Algorithms","page":"AbstractAIFloat Documentation","title":"Type-Generic Algorithms","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"function precision_analysis(T::Type{<:AbstractAIFloat})\n    \"\"\"Generic analysis that works for any AbstractAIFloat type.\"\"\"\n    \n    # Compute relative precision at different scales\n    values = value_sequence(T)\n    finite_vals = filter(isfinite, values)\n    positive_vals = filter(x -> x > 0, finite_vals)\n    sort!(positive_vals)\n    \n    # Sample different magnitude ranges\n    n = length(positive_vals)\n    sample_indices = [1, n√∑4, n√∑2, 3*n√∑4, n]\n    \n    println(\"Relative precision analysis for $(T):\")\n    println(\"Value\\t\\tNext Value\\tRelative Gap\")\n    \n    for i in sample_indices[1:end-1]\n        val = positive_vals[i]\n        next_val = positive_vals[i+1]\n        rel_gap = (next_val - val) / val\n        println(\"$(val)\\t$(next_val)\\t$(rel_gap)\")\n    end\nend","category":"page"},{"location":"ai_abstract_float/#Performance-Optimization","page":"AbstractAIFloat Documentation","title":"Performance Optimization","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"# Efficient batch operations using type properties\nfunction batch_type_analysis(types::Vector{Type})\n    \"\"\"Efficiently analyze multiple types.\"\"\"\n    \n    results = Dict{Type, Dict{Symbol, Any}}()\n    \n    for T in types\n        # Pre-compute commonly used values\n        bits = nBits(T)\n        sig_bits = nSigBits(T)\n        \n        results[T] = Dict(\n            :bits => bits,\n            :sig_bits => sig_bits,\n            :signed => is_signed(T),\n            :extended => is_extended(T),\n            :total_values => 1 << bits,  # More efficient than nValues(T)\n            :finite_values => nFiniteValues(T),\n            :dynamic_range => expMaxValue(T) / expMinValue(T)\n        )\n    end\n    \n    return results\nend","category":"page"},{"location":"ai_abstract_float/#Performance-Considerations","page":"AbstractAIFloat Documentation","title":"Performance Considerations","text":"","category":"section"},{"location":"ai_abstract_float/#Memory-Usage","page":"AbstractAIFloat Documentation","title":"Memory Usage","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"Type-level computations: All property functions operate on types, not instances, with zero runtime memory overhead\nValue sequences: value_sequence(T) generates complete value arrays - memory usage is O(2^nBits)\nLazy evaluation: Consider using iterators for large bit widths:","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"# For large types, use iterators instead of materializing full sequences\nfunction iter_finite_values(T)\n    values = value_sequence(T)\n    Iterators.filter(isfinite, values)\nend","category":"page"},{"location":"ai_abstract_float/#Compilation-Performance","page":"AbstractAIFloat Documentation","title":"Compilation Performance","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"Type specialization: All functions are specialized on type parameters for optimal performance\nCompile-time evaluation: Many properties can be computed at compile time\n@inline annotations: Critical path functions are marked @inline for zero-cost abstractions","category":"page"},{"location":"ai_abstract_float/#Scaling-Guidelines","page":"AbstractAIFloat Documentation","title":"Scaling Guidelines","text":"","category":"section"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"Bit Width Total Values Memory (Float64) Recommended Use\n3-bit 8 64 B ‚úÖ Minimal testing, proof of concept\n4-bit 16 128 B ‚úÖ Toy examples, algorithm verification\n5-bit 32 256 B ‚úÖ Educational demonstrations\n6-bit 64 512 B ‚úÖ Small-scale experiments\n7-bit 128 1 KB ‚úÖ Research prototypes\n8-bit 256 2 KB ‚úÖ Development, testing\n10-bit 1,024 8 KB ‚úÖ AI model components\n12-bit 4,096 32 KB ‚úÖ Production inference\n14-bit 16,384 128 KB ‚ö†Ô∏è Large models, use iterators for sequences","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"This documentation covers the complete AbstractAIFloat API. For additional examples and advanced use cases, see the test suite and example implementations.","category":"page"},{"location":"ai_abstract_float/","page":"AbstractAIFloat Documentation","title":"AbstractAIFloat Documentation","text":"","category":"page"},{"location":"acknowledgements/","page":"Acknowledgements","title":"Acknowledgements","text":"The deep, careful, expert work of P3109 SA is seen everywhere in this workproduct.","category":"page"},{"location":"acknowledgements/","page":"Acknowledgements","title":"Acknowledgements","text":"","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"","category":"page"},{"location":"mathfunctions/","page":"Mathematical Functions","title":"Mathematical Functions","text":"The comparisons <, <=, ==, !=, >=. >, which resolve as Boolean values. ","category":"page"},{"location":"mathfunctions/","page":"Mathematical Functions","title":"Mathematical Functions","text":"The basic unary arithmetic functions \n+x. -x. abs, negate, reciprocal\nThe basic binary arithmetic functions\n+, -, *, /\nEssential numerical selector functions\nminimum, maximum\nminmumMagnitude, maximumMagnitude\nTheir Number-only variants that ignore NaNs,\nminimumNumber, maximumNumber\nminimumMagnitudeNumber, maximumMagnitudeNumber","category":"page"},{"location":"mathfunctions/","page":"Mathematical Functions","title":"Mathematical Functions","text":"","category":"page"},{"location":"overview/#Floating-Point-Types-Consistent-with-P3109","page":"Overview","title":"Floating-Point Types Consistent with P3109","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The IEEE SA P3109 Working Group  is drafting a standard for floating-point formats used in machine learning.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Here are floating-point types consistent with the current draft of The Interim Report. .</br> However, until the IEEE issues the Standard, there may substantive changes.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"specifics/","page":"Type Specifics","title":"Type Specifics","text":"These features are obtainable for all of our floating-point formats.","category":"page"},{"location":"specifics/","page":"Type Specifics","title":"Type Specifics","text":"These predicates: is_signed, is_unsigned, is_finite, is_extended. ","category":"page"},{"location":"specifics/","page":"Type Specifics","title":"Type Specifics","text":"These characterizing counts:","category":"page"},{"location":"specifics/","page":"Type Specifics","title":"Type Specifics","text":"bitwidth, precision,\nnValues, nNumericValues, nFiniteValues, nNormalValues, nSubnormalValues,\nnMagnitudes, nFiniteMagnitudes nNormalMagnitudes, nSubnormalMagnitudes,\n\nnBits, nSignBits, nExpBits, nSigBits, nFracBits","category":"page"},{"location":"specifics/","page":"Type Specifics","title":"Type Specifics","text":"These extremal values:","category":"page"},{"location":"specifics/","page":"Type Specifics","title":"Type Specifics","text":"floatmin, floatmax, exponent_min, exponent_max\nsubnormal_min, subnormal_max, normal_min, normal_max","category":"page"},{"location":"specifics/","page":"Type Specifics","title":"Type Specifics","text":"","category":"page"},{"location":"abstractions/#Abstractions","page":"Computing over Type abstractions","title":"Abstractions","text":"","category":"section"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"graph TD\n    A[AbstractAIFloat]\n    A--> S[AbsSignedFloat]\n    A--> U[AbsUnsignedFloat]\n    S--> SF[AbsSignedFiniteFloat]\n    S--> SE[AbsSignedExtendedFloat]\n    U--> UF[AbsUnsignedFiniteFloat]\n    U--> UE[AbsUnsignedExtendedFloat]","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"graph LR\n    A[AbstractAIFloat]\n    A--> S[Signed]\n    A--> U[Unsigned]\n    S--> SF[Finite ‚äï NaN]\n    S--> SE[Finite ‚äï Inf ‚äï NaN]\n    U--> UF[Finite ‚äï NaN]\n    U--> UE[Finite ‚äï Inf ‚äï NaN]","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"","category":"page"},{"location":"abstractions/#Computing-over-these-abstractions","page":"Computing over Type abstractions","title":"Computing over these abstractions","text":"","category":"section"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"Every predicate, count, and extremal value available in [Type Specifics] is defined over these abstract types. We do not require instantiations to know characterizations.  The way that we stage our abstract parameterizations allows the freedom to use declarations like this:","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"abstract type AbstractAIFloat{Bits, Precision} <: AbstractFloat end\n#                        B is Bits, P is Precision == SigBits\nbitsize(::Type{<:AbstractAIFloat{B,P}}) where {B,P} = B\nsigbits(::Type{<:AbstractAIFloat{B,P}}) where {B,P} = P\n# the fractional bits (or trailing significand bits) are explicitly stored\nfracbits(::Type{<:AbstractAIFloat{B,P}}) where {B,P} = P - 1\n\nsignbits(T::Type{<:AbstractAIFloat{Bits,Precision}}) where {Bits,Precision} =\n     0 + is_signed(T)\n\nexpbits(T::Type{<:AbstractAIFloat{Bits,Precision}}) where {Bits,Precision} =\n   Bits - Precision + is_unsigned(T)\n\nnValues(T::Type{<:AbstractAIFloat}) = 2^nBits(T)\nnNumericValues(T::Type{<:AbstractAIFloat}) = nValues(T) - 1 # remove NaN\nnFiniteValues(T::Type{<:AbstractAIFloat}) = nNumericValues(T) - nInfs(T) # remove Infs\n\nnInfs(T::Type{<:AbstractAIFloat}) = is_extended(T) * (is_signed(T) + is_extended(T))","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"and then","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"for F in (:bitsize, :sigbits, :fracbits, :expbits, :signbits,\n          :nValues, :nNumericValues, :nFiniteValues, :nInfs)\n    @eval $(F)(x::AbstractAIFloat) = $(F)(typeof(x))\nend","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"====","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"In essence, this code provides a framework for creating custom floating-point numeric types in Julia by defining essential properties and methods that describe their bit structure. It allows the user to query information about bits, significance, and the count of representable values including handling special cases like NaN and infinity. This abstraction enables more straightforward implementation and manipulation of different floating-point representations in a systematic way.","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"","category":"page"},{"location":"#AIFloats","page":"Home","title":"AIFloats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The IEEE SA P3109 Working Group  is drafting a standard for floating-point formats used in machine learning.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are defining a family of data formats and providing binary arithmetic optimized for machine learning and related domains. The intent is to provide a consistent and flexible arithmetic framework optimized for Machine Learning Systems that may be implemented in hardware or in software or both combined. Having a shared standard improves interoperability.  The formats are designed to be efficient, consistent and highly performant.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is the source code for this package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
