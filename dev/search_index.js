var documenterSearchIndex = {"docs":
[{"location":"manual/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"manual/overview/#Computational-Paradigm","page":"Overview","title":"Computational Paradigm","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"AIFloats implements a family of reduced-precision floating-point formats specifically engineered for machine learning workloads. Unlike traditional IEEE 754 formats, these representations prioritize computational continuity over numerical precision, eliminating exception states that disrupt gradient flow during training.","category":"page"},{"location":"manual/overview/#Bit-Allocation-Strategy","page":"Overview","title":"Bit Allocation Strategy","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"The fundamental design principle allocates bits according to the inequality:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"textbitwidth geq textprecision + textsignbit + textminimum_exponent_bits","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Where:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Signed formats: 1 ≤ precision < bitwidth ≤ 15  \nUnsigned formats: 1 ≤ precision ≤ bitwidth ≤ 15","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"This constraint ensures sufficient exponent range while maximizing significand precision within the bit budget.","category":"page"},{"location":"manual/overview/#Exponent-Field-Sizing","page":"Overview","title":"Exponent Field Sizing","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"The exponent field width follows the relation:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"nbits_exp(T::Type{<:AbstractSigned}) = nbits(T) - nbits_sig(T)\nnbits_exp(T::Type{<:AbstractUnsigned}) = nbits(T) - nbits_sig(T) + 1","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Unsigned formats gain an additional exponent bit by eliminating the sign bit, providing extended dynamic range for magnitude-only representations.","category":"page"},{"location":"manual/overview/#Value-Domain-Partitioning","page":"Overview","title":"Value Domain Partitioning","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Each format partitions its 2^textbitwidth encodings into distinct regions:","category":"page"},{"location":"manual/overview/#Prenormal-Region","page":"Overview","title":"Prenormal Region","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Contains zero plus subnormal magnitudes where the implicit leading bit is 0:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Zero: Always encoded as 0b0...0\nSubnormal values: textsignificand times 2^textexp_min where significand in (0 1)","category":"page"},{"location":"manual/overview/#Normal-Region","page":"Overview","title":"Normal Region","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Standard IEEE-style representation with implicit leading 1:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Normal values: (1 + textfraction) times 2^textunbiased_exponent\nBiased exponents: Raw exponent field offset by format-specific bias","category":"page"},{"location":"manual/overview/#Special-Values","page":"Overview","title":"Special Values","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"NaN: Deterministically placed opposite zero encoding\nInfinities (Extended formats only): Maximum exponent with specific significand patterns","category":"page"},{"location":"manual/overview/#Exception-Free-Arithmetic","page":"Overview","title":"Exception-Free Arithmetic","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"The critical design innovation eliminates computational exceptions through:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Deterministic NaN placement: No runtime NaN generation from valid operands\nSaturation semantics: Overflow clamps to finite maximum rather than infinity\nContinuous gradient flow: No exceptional states interrupt backpropagation","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"This approach ensures that training dynamics remain stable even with aggressive precision reduction.","category":"page"},{"location":"manual/overview/#Memory-Layout-Optimization","page":"Overview","title":"Memory Layout Optimization","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"AIFloats employs cache-aligned allocation patterns to maximize throughput:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"# Values and codes use aligned allocation for L1 cache efficiency\nfloats = memalign_clear(Float64, nvalues)  # Cache-line aligned\ncodes = memalign_clear(UInt8, nvalues)     # Corresponding encodings","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"The dual-array structure (values, encodings) enables both:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Direct computation: Operating on decoded floating-point values\nTable lookup: Ultra-fast encoding/decoding via array indexing","category":"page"},{"location":"manual/overview/#Precision-vs.-Range-Trade-offs","page":"Overview","title":"Precision vs. Range Trade-offs","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Format selection involves balancing numerical precision against dynamic range:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Format Bitwidth Precision Range Use Case\nsf4p2 4 2 ±1.5 Activation gradients\nuf6p3 6 3 [0, 7.5] Attention weights\nse8p4 8 4 ±240 Feature maps","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"The format taxonomy enables fine-grained optimization for specific tensor roles within neural network architectures.","category":"page"},{"location":"manual/overview/#Performance-Characteristics","page":"Overview","title":"Performance Characteristics","text":"","category":"section"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"AIFloats achieve computational efficiency through multiple pathways:","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"Small formats (≤6 bits): Complete lookup tables for all unary/binary operations\nMedium formats (7-8 bits): Hybrid approach with selective table acceleration  \nLarge formats (≥9 bits): Direct computation with efficient projection","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"This tiered strategy minimizes memory footprint while maximizing computational throughput across the precision spectrum.","category":"page"},{"location":"manual/overview/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#AIFloats.CODE","page":"Reference","title":"AIFloats.CODE","text":"CODE\n\nThe built-in Unsigned Integer types available for encodings.\n\nUInt8 for bitwidths <= 8\nUInt16 for bitwidths > 8\n\nsee also FLOAT\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#AIFloats.CODE_TYPES","page":"Reference","title":"AIFloats.CODE_TYPES","text":"CODE\n\nThe built-in Unsigned Integer types available for encodings.\n\nUInt8 for bitwidths <= 8\nUInt16 for bitwidths > 8\n\nsee also FLOAT\n\n\n\n\n\n","category":"constant"},{"location":"95-reference/#AIFloats.FLOAT","page":"Reference","title":"AIFloats.FLOAT","text":"FLOAT\n\nThe built-in floating-point types available for valuations.\n\nFloat32 for bitwidths  <= 7\nFloat64 for bitwidths  > 8\nFloat128 for bitwidths > 11\n\nsee also CODE\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#AIFloats.FLOAT_TYPES","page":"Reference","title":"AIFloats.FLOAT_TYPES","text":"FLOAT\n\nThe built-in floating-point types available for valuations.\n\nFloat32 for bitwidths  <= 7\nFloat64 for bitwidths  > 8\nFloat128 for bitwidths > 11\n\nsee also CODE\n\n\n\n\n\n","category":"constant"},{"location":"95-reference/#AIFloats.AbstractAIFloat","page":"Reference","title":"AIFloats.AbstractAIFloat","text":"AbstractAIFloat{bitwidth, precision}\n\nsupertype: AbstractFloat\n\nsee AbstractSigned, AbstractUnsigned\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#AIFloats.AbstractSigned","page":"Reference","title":"AIFloats.AbstractSigned","text":"AbstractSigned{bitwidth, precision}\n\nsupertype: AbstractAIFloat\n\nsee AbstractAIFloat, AbstractUnsigned\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#AIFloats.AbstractUnsigned","page":"Reference","title":"AIFloats.AbstractUnsigned","text":"AbstractUnsigned{bitwidth, precision}\n\nsupertype: AbstractAIFloat\n\nsee AbstractAIFloat, AbstractSigned\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#AIFloats.AkoSignedExtended","page":"Reference","title":"AIFloats.AkoSignedExtended","text":"AkoSignedExtended{bitwidth, precision}\n\nsupertype: AbstractSigned\n\nsee AIFloat, AkoSignedFinite, AbstractSigned,\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#AIFloats.AkoSignedFinite","page":"Reference","title":"AIFloats.AkoSignedFinite","text":"AkoSignedFinite{bitwidth, precision}\n\nsupertype: AbstractSigned\n\nsee AIFloat, AkoSignedExtended, AbstractSigned,\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#AIFloats.AkoUnsignedExtended","page":"Reference","title":"AIFloats.AkoUnsignedExtended","text":"AkoUnsignedExtended{bitwidth, precision}\n\nsupertype: AbstractUnsigned\n\nsee AIFloat, AkoUnsignedFinite, AbstractUnsigned\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#AIFloats.AkoUnsignedFinite","page":"Reference","title":"AIFloats.AkoUnsignedFinite","text":"AkoUnsignedFinite{bitwidth, precision}\n\nsupertype: AbstractUnsigned\n\nsee AIFloat, AkoUnsignedExtended, AbstractUnsigned,\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#AIFloats.AIFloat","page":"Reference","title":"AIFloats.AIFloat","text":"AIFloat(<:AbstractAIFloat)\n\nAIFloat(bitwidth, precision, `<signedness>`, `<domain`)\n\nbitwidth is the total number of bits in the floating-point representation\nprecision is the number of bits in the significand (implicit bit + fractional bits)\n<signedness> is one of {:signed, :unsigned} \n<domain>     is one of {:finite, :extended} \n\ngenerates a corresponding concrete AI floating-point type\n\nsee floats, codes\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.code_to_index","page":"Reference","title":"AIFloats.code_to_index","text":"code_to_index(n, code)\n\nconvert the P3019 encoding to a Julia index\n\n(64, 0x1e) ↦ 31\n(32, 0x1d) ↦ 30\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.code_to_value","page":"Reference","title":"AIFloats.code_to_value","text":"code_to_value(values, code)\n\n- values[code+1] i f   0 <= code < length(values)\n                 else NaN\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.codes","page":"Reference","title":"AIFloats.codes","text":"codes(x_or_T)\n\nthe canonical encoding sequence for the given type.\n\nsee AIFloat, floats, x_or_T\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.floats","page":"Reference","title":"AIFloats.floats","text":"floats(x_or_T)\n\nthe canonical value sequence for the given type.\n\nsee AIFloat, codes, x_or_T\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.index_to_code","page":"Reference","title":"AIFloats.index_to_code","text":"index_to_code(n, index)\n\nconvert the Julia index (1-based) into a P3109 encoding (0-based)\n\n(8, 31) ↦ 0x1e\n(9, 30) ↦ 0x1d\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.index_to_value","page":"Reference","title":"AIFloats.index_to_value","text":"index_to_value(values, idx)\n\n- values[idx] if   0 < idx <= length(values)\n              else NaN\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.typeforcode","page":"Reference","title":"AIFloats.typeforcode","text":"typeforcode(bitwidth)\n\nThe bitstype to be used for encoding values of bitwidth\n\nIt is an unchecked error to set bitwidth outside BitsMin..BitsMax\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.typeforfloat","page":"Reference","title":"AIFloats.typeforfloat","text":"typeforfloat(bitwidth)\n\nThe bitstype to be used for storing values of bitwidth\n\nIt is an unchecked error to set bitwidth outside BitsMin..BitsMax\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.validate_code","page":"Reference","title":"AIFloats.validate_code","text":"validate_code(n::Integer, code::Unsigned)\n\ncode or nothing\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.validate_index","page":"Reference","title":"AIFloats.validate_index","text":"validate_index(n::Integer, code::Unsigned)\n\ncode or nothing\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.value_to_code","page":"Reference","title":"AIFloats.value_to_code","text":"value_to_code\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.value_to_index","page":"Reference","title":"AIFloats.value_to_index","text":"value_to_index\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.x_or_T","page":"Reference","title":"AIFloats.x_or_T","text":"x_or_T\n\nfunc(x_or_T) means func works with abstract and concrete arguments\n\nthe concrete x::T \nthe abstract T::Type\n\n\n\n\n\n","category":"function"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"manual/hierarchy/#Type-Hierarchy","page":"Type Hierarchy","title":"Type Hierarchy","text":"","category":"section"},{"location":"manual/hierarchy/#Abstract-Type-Foundation","page":"Type Hierarchy","title":"Abstract Type Foundation","text":"","category":"section"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"The AIFloats type system employs a three-parameter abstract hierarchy that captures both structural and semantic properties:","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"abstract type AbstractAIFloat{Bits, SigBits, IsSigned} <: AbstractFloat end","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"This parametric design enables compile-time specialization while maintaining runtime polymorphism across the format family.","category":"page"},{"location":"manual/hierarchy/#Primary-Abstractions","page":"Type Hierarchy","title":"Primary Abstractions","text":"","category":"section"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"abstract type AbstractSigned{Bits, SigBits} <: AbstractAIFloat{Bits, SigBits, true} end\nabstract type AbstractUnsigned{Bits, SigBits} <: AbstractAIFloat{Bits, SigBits, false} end","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"The IsSigned parameter is embedded as a type-level boolean, eliminating runtime dispatch overhead for signedness-dependent operations.","category":"page"},{"location":"manual/hierarchy/#Domain-Specific-Abstractions","page":"Type Hierarchy","title":"Domain-Specific Abstractions","text":"","category":"section"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"The hierarchy further stratifies by representable value domains:","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"# Finite formats: Real numbers ∪ {NaN}\nabstract type AkoSignedFinite{Bits, SigBits} <: AbstractSigned{Bits, SigBits} end\nabstract type AkoUnsignedFinite{Bits, SigBits} <: AbstractUnsigned{Bits, SigBits} end\n\n# Extended formats: Real numbers ∪ {±∞, NaN} or {+∞, NaN}\nabstract type AkoSignedExtended{Bits, SigBits} <: AbstractSigned{Bits, SigBits} end\nabstract type AkoUnsignedExtended{Bits, SigBits} <: AbstractUnsigned{Bits, SigBits} end","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"The Ako prefix (from \"A kind of\") distinguishes domain abstractions from structural ones, enabling precise dispatch without naming conflicts.","category":"page"},{"location":"manual/hierarchy/#Type-Parameter-Constraints","page":"Type Hierarchy","title":"Type Parameter Constraints","text":"","category":"section"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"The type system enforces mathematical consistency through compile-time parameter validation:","category":"page"},{"location":"manual/hierarchy/#Signed-Format-Constraints","page":"Type Hierarchy","title":"Signed Format Constraints","text":"","category":"section"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"# Require: 3 ≤ Bits ≤ 15, 1 ≤ SigBits < Bits\n# Minimum configuration: 1 sign + 1 exponent + 1 significand bit","category":"page"},{"location":"manual/hierarchy/#Unsigned-Format-Constraints","page":"Type Hierarchy","title":"Unsigned Format Constraints","text":"","category":"section"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"# Require: 3 ≤ Bits ≤ 15, 1 ≤ SigBits ≤ Bits\n# Additional exponent bit available: nbits_exp = Bits - SigBits + 1","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"These constraints prevent degenerate configurations while maximizing the useful parameter space.","category":"page"},{"location":"manual/hierarchy/#Concrete-Type-Structure","page":"Type Hierarchy","title":"Concrete Type Structure","text":"","category":"section"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"Concrete implementations store both floating-point values and their integer encodings:","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"struct SignedFinite{bits, sigbits, T<:AbstractFloat, S<:Unsigned} <: AkoSignedFinite{bits, sigbits}\n    floats::Vector{T}  # Canonical value sequence\n    codes::Vector{S}   # Corresponding bit encodings\nend","category":"page"},{"location":"manual/hierarchy/#Storage-Type-Selection","page":"Type Hierarchy","title":"Storage Type Selection","text":"","category":"section"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"The T and S parameters are automatically determined by bitwidth:","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"typeforfloat(bits) = bits ≤ 8 ? Float64 : (bits ≤ 11 ? Float64 : Float128)\ntypeforcode(bits) = bits ≤ 8 ? UInt8 : UInt16","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"This selection balances precision requirements against memory efficiency.","category":"page"},{"location":"manual/hierarchy/#Method-Dispatch-Patterns","page":"Type Hierarchy","title":"Method Dispatch Patterns","text":"","category":"section"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"The hierarchy enables sophisticated dispatch strategies that minimize runtime overhead:","category":"page"},{"location":"manual/hierarchy/#Abstract-Concrete-Duality","page":"Type Hierarchy","title":"Abstract-Concrete Duality","text":"","category":"section"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"Every method supports both type-level and instance-level invocation:","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"# Type-level dispatch (compile-time resolution)\nnbits(::Type{T}) where {Bits, SigBits, T<:AbstractAIFloat{Bits, SigBits}} = Bits\n\n# Instance-level dispatch (automatic forwarding)\nnbits(x::T) where {T<:AbstractAIFloat} = nbits(T)","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"This pattern eliminates redundant implementations while preserving both programming paradigms.","category":"page"},{"location":"manual/hierarchy/#Signedness-Aware-Dispatch","page":"Type Hierarchy","title":"Signedness-Aware Dispatch","text":"","category":"section"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"The type system naturally partitions methods by signedness requirements:","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"# Signed-only operations\ncode_negone(::Type{T}) where {T<:AbstractSigned} = ...\ncode_negone(::Type{T}) where {T<:AbstractUnsigned} = nothing\n\n# Universal operations with signedness-dependent implementation\nnmagnitudes(T::Type{<:AbstractUnsigned}) = 2^nbits(T) - 1\nnmagnitudes(T::Type{<:AbstractSigned}) = 2^(nbits(T) - 1)","category":"page"},{"location":"manual/hierarchy/#Domain-Specific-Specialization","page":"Type Hierarchy","title":"Domain-Specific Specialization","text":"","category":"section"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"Extended vs. finite domain differences require specialized handling:","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"nInfs(::Type{<:AkoSignedFinite}) = 0\nnInfs(::Type{<:AkoSignedExtended}) = 2\nnInfs(::Type{<:AkoUnsignedFinite}) = 0  \nnInfs(::Type{<:AkoUnsignedExtended}) = 1","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"This approach ensures that domain-specific properties compile to optimal code without runtime conditionals.","category":"page"},{"location":"manual/hierarchy/#Type-Level-Computation-Benefits","page":"Type Hierarchy","title":"Type-Level Computation Benefits","text":"","category":"section"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"The parametric design enables extensive compile-time precomputation:","category":"page"},{"location":"manual/hierarchy/#Bit-Field-Calculations","page":"Type Hierarchy","title":"Bit Field Calculations","text":"","category":"section"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"# Exponent field width computed at compile time\nnbits_exp(::Type{<:AbstractSigned{Bits, SigBits}}) where {Bits, SigBits} = Bits - SigBits\nnbits_exp(::Type{<:AbstractUnsigned{Bits, SigBits}}) where {Bits, SigBits} = Bits - SigBits + 1","category":"page"},{"location":"manual/hierarchy/#Count-Computations","page":"Type Hierarchy","title":"Count Computations","text":"","category":"section"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"# Value counts resolved during compilation\nnvalues(::Type{<:AbstractAIFloat{Bits}}) where {Bits} = 2^Bits\nnmagnitudes_prenormal(::Type{<:AbstractAIFloat{Bits, SigBits}}) where {Bits, SigBits} = 2^(SigBits - 1)","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"This compile-time resolution eliminates computational overhead for format introspection operations.","category":"page"},{"location":"manual/hierarchy/#Hierarchy-Traversal-Utilities","page":"Type Hierarchy","title":"Hierarchy Traversal Utilities","text":"","category":"section"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"The package provides predicates for runtime type classification:","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"is_aifloat(::Type{<:AbstractAIFloat}) = true\nis_signed(::Type{<:AbstractSigned}) = true\nis_finite(::Type{<:AkoSignedFinite}) = true\nis_extended(::Type{<:AkoSignedExtended}) = true","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"These predicates enable generic programming while maintaining type safety and performance characteristics.","category":"page"},{"location":"manual/hierarchy/","page":"Type Hierarchy","title":"Type Hierarchy","text":"","category":"page"},{"location":"manual/construction/#Construction-Methods","page":"Construction","title":"Construction Methods","text":"","category":"section"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"AIFloats provides dual construction pathways that accommodate both abstract type specifications and direct parameter-based instantiation, enabling flexible integration into diverse computational workflows.","category":"page"},{"location":"manual/construction/#Primary-Constructor-Interface","page":"Construction","title":"Primary Constructor Interface","text":"","category":"section"},{"location":"manual/construction/#Parametric-Construction","page":"Construction","title":"Parametric Construction","text":"","category":"section"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"The canonical construction method accepts bitwidth, precision, and domain qualifiers:","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"AIFloat(bitwidth::Int, precision::Int, signedness::Symbol, domain::Symbol)","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"Parameter Validation: The constructor enforces strict mathematical constraints during instantiation:","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"# Signed format constraints: sign bit reduces available width\nsignedness == :signed && bitwidth > precision  # Minimum: 3 bits\n# Unsigned format constraints: full width available for magnitude\nsignedness == :unsigned && bitwidth >= precision  # Minimum: 2 bits","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"Domain Specification: The domain qualifier controls special value semantics:","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":":finite → Finite reals ∪ {NaN}\n:extended → Finite reals ∪ {NaN, ±∞} or {NaN, +∞}","category":"page"},{"location":"manual/construction/#Construction-Examples","page":"Construction","title":"Construction Examples","text":"","category":"section"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"# 4-bit signed finite: [-1.5, +1.5] ∪ {NaN}\nsf4p2 = AIFloat(4, 2, :signed, :finite)\n\n# 6-bit unsigned extended: [0, 7.875] ∪ {+∞, NaN}  \nue6p3 = AIFloat(6, 3, :unsigned, :extended)\n\n# 8-bit signed extended: maximum dynamic range with infinities\nse8p4 = AIFloat(8, 4, :signed, :extended)","category":"page"},{"location":"manual/construction/#Abstract-Type-Based-Construction","page":"Construction","title":"Abstract Type-Based Construction","text":"","category":"section"},{"location":"manual/construction/#Type-Driven-Instantiation","page":"Construction","title":"Type-Driven Instantiation","text":"","category":"section"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"For generic programming scenarios, construction from abstract types enables parametric algorithms:","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"# Construct from parameterized abstract type\nT = AkoSignedFinite{5, 3}\nsf5p3 = AIFloat(T)\n\n# Extract parameters for algorithmic construction\nbits, precision = nbits(T), nbits_sig(T)\nfamily_member = AIFloat(bits, precision, :signed, :finite)","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"This approach facilitates type-stable generic functions that operate across format families.","category":"page"},{"location":"manual/construction/#Internal-Construction-Pipeline","page":"Construction","title":"Internal Construction Pipeline","text":"","category":"section"},{"location":"manual/construction/#Memory-Allocation-Strategy","page":"Construction","title":"Memory Allocation Strategy","text":"","category":"section"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"The construction process employs cache-aligned allocation for optimal memory access patterns:","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"function ConstructAIFloat(bitwidth::Int, sigbits::Int; plusminus::Bool, extended::Bool)\n    F = typeforfloat(bitwidth)  # Float64 or Float128 based on precision requirements\n    S = typeforcode(bitwidth)   # UInt8 or UInt16 based on encoding width\n    \n    # Generate canonical sequences with aligned allocation\n    codes = encoding_seq(S, bitwidth)           # 0x00, 0x01, ..., 0xFF\n    floats = value_seq(concrete_type, ...)      # Corresponding FP values\n    \n    return ConcreteType{bitwidth, sigbits, F, S}(floats, codes)\nend","category":"page"},{"location":"manual/construction/#Value-Sequence-Generation","page":"Construction","title":"Value Sequence Generation","text":"","category":"section"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"The constructor synthesizes mathematically precise value sequences through multi-stage computation:","category":"page"},{"location":"manual/construction/#Stage-1:-Magnitude-Foundation","page":"Construction","title":"Stage 1: Magnitude Foundation","text":"","category":"section"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"function magnitude_foundation_seq(::Type{T}) where {T<:AbstractAIFloat}\n    # Generate normalized significand sequence\n    significands = significand_magnitudes(T)\n    \n    # Compute scaled exponent values with extended precision\n    exp_values = map(x -> Float128(2)^x, exp_unbiased_magnitude_strides(T))\n    \n    # Element-wise scaling: significand × 2^exponent\n    scaled_magnitudes = significands .* exp_values\n    \n    return convert_to_working_precision(scaled_magnitudes, T)\nend","category":"page"},{"location":"manual/construction/#Stage-2:-Sign-and-Special-Value-Integration","page":"Construction","title":"Stage 2: Sign and Special Value Integration","text":"","category":"section"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"function value_seq(::Type{T}) where {T<:AkoSignedFinite}\n    nonneg_magnitudes = magnitude_foundation_seq(T)\n    \n    # Generate negative counterparts with sign symmetry\n    neg_magnitudes = -nonneg_magnitudes\n    neg_magnitudes[1] = convert(working_type, NaN)  # NaN at symmetric position\n    \n    return vcat(nonneg_magnitudes, neg_magnitudes)\nend","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"This approach ensures bit-exact reproducibility across platforms while maintaining numerical accuracy.","category":"page"},{"location":"manual/construction/#Format-Specific-Construction-Details","page":"Construction","title":"Format-Specific Construction Details","text":"","category":"section"},{"location":"manual/construction/#Exponent-Bias-Computation","page":"Construction","title":"Exponent Bias Computation","text":"","category":"section"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"The bias calculation establishes symmetric exponent ranges:","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"# Signed formats: traditional IEEE-style bias\nexp_bias(::Type{<:AbstractSigned{Bits, SigBits}}) = 2^(Bits - SigBits - 1)\n\n# Unsigned formats: enhanced bias due to additional exponent bit  \nexp_bias(::Type{<:AbstractUnsigned{Bits, SigBits}}) = 2^(Bits - SigBits)","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"This asymmetric bias allocation maximizes dynamic range utilization within bit budget constraints.","category":"page"},{"location":"manual/construction/#Subnormal-Threshold-Determination","page":"Construction","title":"Subnormal Threshold Determination","text":"","category":"section"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"The prenormal/normal boundary is established through precision-dependent scaling:","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"# Smallest normal magnitude: 2^(exp_min) where implicit bit = 1\nmagnitude_normal_min(T) = exp_value_min(T)\n\n# Largest subnormal magnitude: (1 - ε) × 2^(exp_min) where ε = ULP\nmagnitude_subnormal_max(T) = (1 - 1/nmagnitudes_prenormal(T)) * exp_subnormal_value(T)","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"This boundary placement ensures maximal precision utilization in the critical near-zero region.","category":"page"},{"location":"manual/construction/#Construction-Validation-and-Error-Handling","page":"Construction","title":"Construction Validation and Error Handling","text":"","category":"section"},{"location":"manual/construction/#Parameter-Range-Validation","page":"Construction","title":"Parameter Range Validation","text":"","category":"section"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"The constructor performs comprehensive parameter validation with informative error messages:","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"function validate_construction_parameters(bitwidth, precision, signedness)\n    # Bit budget validation\n    min_bitwidth = (signedness == :signed) ? precision + 2 : precision + 1\n    bitwidth >= min_bitwidth || throw(ArgumentError(\n        \"Insufficient bit budget: $bitwidth < $min_bitwidth for $signedness format\"))\n    \n    # Precision constraints\n    1 ≤ precision ≤ 15 || throw(ArgumentError(\n        \"Precision out of range: $precision ∉ [1, 15]\"))\n    \n    # Implementation limits\n    bitwidth ≤ 15 || throw(ArgumentError(\n        \"Bitwidth exceeds maximum: $bitwidth > 15\"))\nend","category":"page"},{"location":"manual/construction/#Type-Consistency-Verification","page":"Construction","title":"Type Consistency Verification","text":"","category":"section"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"Post-construction verification ensures mathematical consistency:","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"function verify_construction_invariants(aifloat::AbstractAIFloat)\n    @assert length(floats(aifloat)) == nvalues(typeof(aifloat))\n    @assert length(codes(aifloat)) == nvalues(typeof(aifloat))\n    @assert issorted(floats(aifloat)[1:nmagnitudes(typeof(aifloat))])  # Magnitude ordering\n    @assert codes(aifloat)[1] == 0x00  # Zero encoding\n    @assert isnan(floats(aifloat)[end])  # NaN placement\nend","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"This validation layer prevents subtle construction errors that could compromise numerical correctness.","category":"page"},{"location":"manual/construction/#Performance-Characteristics","page":"Construction","title":"Performance Characteristics","text":"","category":"section"},{"location":"manual/construction/#Construction-Complexity","page":"Construction","title":"Construction Complexity","text":"","category":"section"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"Time Complexity: O(2^bitwidth) for value sequence generation\nSpace Complexity: O(2^bitwidth) for dual array storage  \nCache Efficiency: Aligned allocation enables optimal memory access patterns","category":"page"},{"location":"manual/construction/#Optimization-Strategies","page":"Construction","title":"Optimization Strategies","text":"","category":"section"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"For performance-critical applications, consider:","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"Pre-constructed formats: Cache frequently used format instances\nType-stable construction: Use abstract type parameters when possible\nBatch construction: Amortize validation overhead across multiple instances","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"The construction system balances mathematical precision, computational efficiency, and programmer ergonomics to support diverse floating-point arithmetic applications.","category":"page"},{"location":"manual/construction/","page":"Construction","title":"Construction","text":"","category":"page"},{"location":"tutorials/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"This tutorial provides a hands-on introduction to AIFloats.jl, demonstrating core concepts through practical examples that illustrate the unique characteristics of reduced-precision arithmetic designed for machine learning applications.","category":"page"},{"location":"tutorials/getting_started/#Installation-and-Basic-Setup","page":"Getting Started","title":"Installation and Basic Setup","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"AIFloats\")\nusing AIFloats","category":"page"},{"location":"tutorials/getting_started/#Creating-Your-First-AIFloat-Format","page":"Getting Started","title":"Creating Your First AIFloat Format","text":"","category":"section"},{"location":"tutorials/getting_started/#Understanding-Format-Specification","page":"Getting Started","title":"Understanding Format Specification","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"AIFloat formats are specified by four parameters that completely determine their arithmetic properties:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Create a 4-bit unsigned finite format with 2-bit significand precision\nuf4p2 = AIFloat(4, 2, :unsigned, :finite)\n\n# Examine the complete value domain\nprintln(\"Values: \", floats(uf4p2))\nprintln(\"Codes:  \", codes(uf4p2))","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Output:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Values: [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, NaN]\nCodes:  [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07]","category":"page"},{"location":"tutorials/getting_started/#Analyzing-the-Bit-Layout","page":"Getting Started","title":"Analyzing the Bit Layout","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"The 4-bit unsigned format allocates bits as follows:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Significand: 2 bits (1 implicit + 1 fractional)\nExponent: 3 bits (4 - 2 + 1 for unsigned)\nSign: 0 bits (unsigned format)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Verify bit allocation\nprintln(\"Total bits: \", nbits(uf4p2))           # 4\nprintln(\"Significand bits: \", nbits_sig(uf4p2)) # 2  \nprintln(\"Exponent bits: \", nbits_exp(uf4p2))    # 3\nprintln(\"Sign bits: \", nbits_sign(uf4p2))       # 0","category":"page"},{"location":"tutorials/getting_started/#Exploring-Format-Variants","page":"Getting Started","title":"Exploring Format Variants","text":"","category":"section"},{"location":"tutorials/getting_started/#Signed-vs.-Unsigned-Formats","page":"Getting Started","title":"Signed vs. Unsigned Formats","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Compare equivalent signed and unsigned formats to understand the trade-offs:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"# 4-bit signed finite format\nsf4p2 = AIFloat(4, 2, :signed, :finite)\nprintln(\"Signed values: \", floats(sf4p2))\n\n# 4-bit unsigned finite format  \nuf4p2 = AIFloat(4, 2, :unsigned, :finite)\nprintln(\"Unsigned values: \", floats(uf4p2))","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Output:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Signed values:   [0.0, 0.5, 1.0, 1.5, NaN, -0.5, -1.0, -1.5]\nUnsigned values: [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, NaN]","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Key Observations:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Signed format sacrifices one exponent bit for sign representation\nUnsigned format provides finer granularity in the positive domain\nBoth maintain symmetric NaN placement","category":"page"},{"location":"tutorials/getting_started/#Finite-vs.-Extended-Domains","page":"Getting Started","title":"Finite vs. Extended Domains","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Extended formats incorporate infinities for overflow handling:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Compare finite and extended variants\nuf4_finite = AIFloat(4, 2, :unsigned, :finite)\nuf4_extended = AIFloat(4, 2, :unsigned, :extended)\n\nprintln(\"Finite values:   \", floats(uf4_finite))\nprintln(\"Extended values: \", floats(uf4_extended))","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Output:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Finite values:   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, NaN]\nExtended values: [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, Inf, NaN]","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"The extended format replaces the largest finite magnitude with positive infinity, providing overflow handling at the cost of reduced finite precision.","category":"page"},{"location":"tutorials/getting_started/#Understanding-Value-Organization","page":"Getting Started","title":"Understanding Value Organization","text":"","category":"section"},{"location":"tutorials/getting_started/#Prenormal-and-Normal-Regimes","page":"Getting Started","title":"Prenormal and Normal Regimes","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"AIFloat formats partition values into distinct mathematical regimes:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Create a format with observable subnormal structure\nse6p3 = AIFloat(6, 3, :signed, :extended)\n\n# Examine regime boundaries\nprintln(\"Prenormal count: \", nmagnitudes_prenormal(se6p3))\nprintln(\"Subnormal count: \", nmagnitudes_subnormal(se6p3))  \nprintln(\"Normal count: \", nmagnitudes_normal(se6p3))\n\n# Extract subnormal and normal value ranges\nvalues = floats(se6p3)\nprenormal_end = nmagnitudes_prenormal(se6p3)\n\nprintln(\"Prenormal values: \", values[1:prenormal_end])\nprintln(\"First few normals: \", values[prenormal_end+1:prenormal_end+4])","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"This reveals the transition from fractional scaling (subnormals) to exponential scaling (normals), demonstrating how precision is allocated across the dynamic range.","category":"page"},{"location":"tutorials/getting_started/#Format-Introspection-and-Analysis","page":"Getting Started","title":"Format Introspection and Analysis","text":"","category":"section"},{"location":"tutorials/getting_started/#Querying-Format-Properties","page":"Getting Started","title":"Querying Format Properties","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"AIFloats provides comprehensive introspection capabilities:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Create a representative format for analysis\nse8p4 = AIFloat(8, 4, :signed, :extended)\n\n# Basic format characterization\nprintln(\"Format family: \", is_signed(se8p4) ? \"Signed\" : \"Unsigned\", \n        \", \", is_extended(se8p4) ? \"Extended\" : \"Finite\")\n\n# Count various value categories\nprintln(\"Total values: \", nvalues(se8p4))\nprintln(\"Finite values: \", nvalues_finite(se8p4))\nprintln(\"Positive values: \", nvalues_positive(se8p4))\nprintln(\"Normal values: \", nvalues_normal(se8p4))\nprintln(\"Infinity count: \", nInfs(se8p4))","category":"page"},{"location":"tutorials/getting_started/#Examining-Exponent-Structure","page":"Getting Started","title":"Examining Exponent Structure","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Understanding the exponent system is crucial for effective format utilization:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Analyze exponent characteristics\nprintln(\"Exponent bias: \", exp_bias(se8p4))\nprintln(\"Min unbiased exponent: \", exp_unbiased_min(se8p4))\nprintln(\"Max unbiased exponent: \", exp_unbiased_max(se8p4))\nprintln(\"Subnormal exponent: \", exp_unbiased_subnormal(se8p4))\n\n# Examine exponent value scaling\nprintln(\"Min exponent value: \", exp_value_min(se8p4))\nprintln(\"Max exponent value: \", exp_value_max(se8p4))\nprintln(\"Subnormal scale: \", exp_subnormal_value(se8p4))","category":"page"},{"location":"tutorials/getting_started/#Working-with-Encodings-and-Indices","page":"Getting Started","title":"Working with Encodings and Indices","text":"","category":"section"},{"location":"tutorials/getting_started/#Code-Value-Correspondence","page":"Getting Started","title":"Code-Value Correspondence","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Every AIFloat maintains perfect correspondence between bit patterns and floating-point values:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"sf4p2 = AIFloat(4, 2, :signed, :finite)\n\n# Demonstrate encoding lookup\nfor i in 1:length(codes(sf4p2))\n    code = codes(sf4p2)[i]\n    value = floats(sf4p2)[i]\n    println(\"Code 0x$(string(code, base=16, pad=2)) ↔ Value $value\")\nend","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Output:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Code 0x00 ↔ Value 0.0\nCode 0x01 ↔ Value 0.5\nCode 0x02 ↔ Value 1.0\nCode 0x03 ↔ Value 1.5\nCode 0x04 ↔ Value NaN\nCode 0x05 ↔ Value -0.5\nCode 0x06 ↔ Value -1.0\nCode 0x07 ↔ Value -1.5","category":"page"},{"location":"tutorials/getting_started/#Special-Value-Locations","page":"Getting Started","title":"Special Value Locations","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"AIFloats use deterministic placement for special values:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Locate special value encodings\nprintln(\"Zero code: 0x$(string(code_zero(sf4p2), base=16, pad=2))\")\nprintln(\"One code: 0x$(string(code_one(sf4p2), base=16, pad=2))\")\nprintln(\"NaN code: 0x$(string(code_nan(sf4p2), base=16, pad=2))\")\n\n# For signed formats, negative one is also available\nprintln(\"Negative one code: 0x$(string(code_negone(sf4p2), base=16, pad=2))\")","category":"page"},{"location":"tutorials/getting_started/#Index-Based-Access","page":"Getting Started","title":"Index-Based Access","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Julia's 1-based indexing provides natural access to the value sequences:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Convert between 0-based codes and 1-based indices\ncode = 0x03\nindex = code_to_index(length(floats(sf4p2)), code)\nvalue = floats(sf4p2)[index]\n\nprintln(\"Code $code → Index $index → Value $value\")\n\n# Reverse lookup: find code for a specific value\ntarget_value = 1.0\nfound_index = findfirst(==(target_value), floats(sf4p2))\nfound_code = codes(sf4p2)[found_index]\nprintln(\"Value $target_value → Index $found_index → Code 0x$(string(found_code, base=16, pad=2))\")","category":"page"},{"location":"tutorials/getting_started/#Practical-Applications","page":"Getting Started","title":"Practical Applications","text":"","category":"section"},{"location":"tutorials/getting_started/#Neural-Network-Weight-Quantization","page":"Getting Started","title":"Neural Network Weight Quantization","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Demonstrate AIFloat usage for weight quantization scenarios:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Simulate weight matrix quantization\nusing Random\nRandom.seed!(42)\n\n# Generate synthetic weight matrix\nweights_fp32 = randn(Float32, 4, 4) * 0.5\n\n# Choose quantization format based on weight distribution\nweight_format = AIFloat(6, 3, :signed, :finite)  # 6-bit signed for weights\n\nprintln(\"Original weights (Float32):\")\ndisplay(weights_fp32)\n\n# Quantize by finding nearest representable values\nquantized_weights = similar(weights_fp32)\nfor i in eachindex(weights_fp32)\n    # Find closest AIFloat representation\n    distances = abs.(floats(weight_format) .- weights_fp32[i])\n    closest_idx = argmin(distances)\n    quantized_weights[i] = floats(weight_format)[closest_idx]\nend\n\nprintln(\"\\nQuantized weights (6-bit AIFloat):\")\ndisplay(quantized_weights)\n\n# Analyze quantization error\nmse = mean((weights_fp32 .- quantized_weights).^2)\nprintln(\"\\nQuantization MSE: $mse\")","category":"page"},{"location":"tutorials/getting_started/#Activation-Function-Table-Generation","page":"Getting Started","title":"Activation Function Table Generation","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Create lookup tables for fast activation function evaluation:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Generate ReLU lookup table for small format\nrelu_format = AIFloat(4, 2, :signed, :finite)\nrelu_table = max.(0.0, floats(relu_format))\n\nprintln(\"ReLU lookup table:\")\nfor (code, input, output) in zip(codes(relu_format), floats(relu_format), relu_table)\n    println(\"Code 0x$(string(code, base=16, pad=2)): ReLU($input) = $output\")\nend\n\n# Demonstrate table-based computation\ninput_code = 0x01  # Corresponds to 0.5\noutput_value = relu_table[input_code + 1]  # +1 for Julia indexing\nprintln(\"\\nTable lookup: ReLU($(floats(relu_format)[input_code + 1])) = $output_value\")","category":"page"},{"location":"tutorials/getting_started/#Performance-Considerations","page":"Getting Started","title":"Performance Considerations","text":"","category":"section"},{"location":"tutorials/getting_started/#Memory-Layout-Inspection","page":"Getting Started","title":"Memory Layout Inspection","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Examine the memory-efficient dual-array structure:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Create format and inspect memory layout\nformat = AIFloat(6, 3, :unsigned, :finite)\n\nprintln(\"Memory usage analysis:\")\nprintln(\"Values array: $(sizeof(floats(format))) bytes\")\nprintln(\"Codes array: $(sizeof(codes(format))) bytes\")\nprintln(\"Total overhead: $(sizeof(floats(format)) + sizeof(codes(format))) bytes\")\nprintln(\"Entries: $(length(floats(format)))\")\n\n# Verify cache alignment (requires AlignedAllocs.jl)\nusing AlignedAllocs\nprintln(\"Values alignment: $(alignment(floats(format))) bytes\")\nprintln(\"Codes alignment: $(alignment(codes(format))) bytes\")","category":"page"},{"location":"tutorials/getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"This tutorial covered the fundamental concepts of AIFloat format creation, introspection, and basic manipulation. To continue learning:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"Reference Documentation: Detailed API coverage","category":"page"},{"location":"tutorials/getting_started/#Key-Takeaways","page":"Getting Started","title":"Key Takeaways","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"AIFloat formats provide deterministic, exception-free arithmetic\nBit allocation trades off precision against dynamic range\nDual-array storage enables both direct computation and table lookup\nFormat introspection supports algorithmic format selection\nCache-aligned memory layout optimizes computational performance","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"The next tutorial will demonstrate how to design custom formats optimized for specific neural network architectures and training regimes.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"reference/types/#Type-System-Reference","page":"Type System","title":"Type System Reference","text":"","category":"section"},{"location":"reference/types/#Abstract-Types","page":"Type System","title":"Abstract Types","text":"","category":"section"},{"location":"reference/types/#Core-Hierarchy","page":"Type System","title":"Core Hierarchy","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"The abstract type hierarchy provides the foundation for the AIFloat format family, enabling both compile-time specialization and runtime polymorphism.","category":"page"},{"location":"reference/types/#Domain-Specific-Abstractions","page":"Type System","title":"Domain-Specific Abstractions","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"Domain abstractions distinguish between finite-only formats and those including infinities, enabling precise dispatch for domain-specific operations.","category":"page"},{"location":"reference/types/#Concrete-Types","page":"Type System","title":"Concrete Types","text":"","category":"section"},{"location":"reference/types/#Primary-Implementations","page":"Type System","title":"Primary Implementations","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"Each concrete type stores both the canonical floating-point value sequence and corresponding integer encodings in cache-aligned arrays.","category":"page"},{"location":"reference/types/#Type-Parameters","page":"Type System","title":"Type Parameters","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"All concrete types are parameterized by:","category":"page"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"bits: Total bitwidth (3 ≤ bits ≤ 15)\nsigbits: Significand precision including implicit bit\nT<:AbstractFloat: Storage type for floating-point values\nS<:Unsigned: Storage type for integer encodings","category":"page"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"The storage types are automatically selected based on bitwidth:","category":"page"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"Bitwidth Range Float Type Code Type\n3-8 bits Float64 UInt8\n9-11 bits Float64 UInt16\n12-15 bits Float128 UInt16","category":"page"},{"location":"reference/types/#Type-Parameter-Relationships","page":"Type System","title":"Type Parameter Relationships","text":"","category":"section"},{"location":"reference/types/#Bit-Allocation-Constraints","page":"Type System","title":"Bit Allocation Constraints","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"The type system enforces these mathematical relationships:","category":"page"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"# Signed formats require space for sign bit\nnbits_exp(::Type{<:AbstractSigned{Bits, SigBits}}) = Bits - SigBits\n\n# Unsigned formats gain an extra exponent bit\nnbits_exp(::Type{<:AbstractUnsigned{Bits, SigBits}}) = Bits - SigBits + 1\n\n# Fractional bits exclude implicit leading bit\nnbits_frac(::Type{<:AbstractAIFloat{Bits, SigBits}}) = SigBits - 1","category":"page"},{"location":"reference/types/#Value-Count-Relationships","page":"Type System","title":"Value Count Relationships","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"Total representable values follow these patterns:","category":"page"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"# All formats use full bit space\nnvalues(::Type{<:AbstractAIFloat{Bits}}) = 2^Bits\n\n# Magnitude counts differ by signedness\nnmagnitudes(::Type{<:AbstractUnsigned{Bits}}) = 2^Bits - 1  # Exclude NaN\nnmagnitudes(::Type{<:AbstractSigned{Bits}}) = 2^(Bits-1)    # Half-space","category":"page"},{"location":"reference/types/#Type-Predicates","page":"Type System","title":"Type Predicates","text":"","category":"section"},{"location":"reference/types/#Basic-Classification","page":"Type System","title":"Basic Classification","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"These predicates enable runtime type classification and generic programming patterns.","category":"page"},{"location":"reference/types/#Specialized-Properties","page":"Type System","title":"Specialized Properties","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"Format-specific properties that affect numerical behavior and algorithm selection.","category":"page"},{"location":"reference/types/#Type-Construction-Utilities","page":"Type System","title":"Type Construction Utilities","text":"","category":"section"},{"location":"reference/types/#Storage-Type-Selection","page":"Type System","title":"Storage Type Selection","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"These functions automatically select appropriate storage types based on bitwidth requirements.","category":"page"},{"location":"reference/types/#Format-Validation","page":"Type System","title":"Format Validation","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"The type system validates parameter combinations during construction:","category":"page"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"function validate_parameters(bits::Int, sigbits::Int, signed::Bool)\n    # Basic range checks\n    3 ≤ bits ≤ 15 || error(\"Bitwidth out of range: $bits ∉ [3,15]\")\n    1 ≤ sigbits ≤ bits || error(\"Invalid precision: $sigbits ∉ [1,$bits]\")\n    \n    # Signedness-specific constraints\n    if signed\n        sigbits < bits || error(\"Signed formats require sigbits < bits\")\n    end\n    \n    return true\nend","category":"page"},{"location":"reference/types/#Method-Dispatch-Patterns","page":"Type System","title":"Method Dispatch Patterns","text":"","category":"section"},{"location":"reference/types/#Abstract-Concrete-Duality","page":"Type System","title":"Abstract-Concrete Duality","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"The type system supports both compile-time and runtime method resolution:","category":"page"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"# Type-level methods (compile-time resolution)\nnbits(::Type{T}) where {Bits, SigBits, T<:AbstractAIFloat{Bits, SigBits}} = Bits\n\n# Instance-level methods (automatic forwarding)  \nnbits(x::T) where {T<:AbstractAIFloat} = nbits(T)\n\n# Bulk forwarding via metaprogramming\nfor F in (:nbits, :nbits_sig, :nvalues, :nmagnitudes)\n    @eval $F(x::T) where {T<:AbstractAIFloat} = $F(T)\nend","category":"page"},{"location":"reference/types/#Signedness-Aware-Dispatch","page":"Type System","title":"Signedness-Aware Dispatch","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"Operations naturally partition by signedness requirements:","category":"page"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"# Signed-specific operations\ncode_negone(::Type{T}) where {T<:AbstractSigned} = # implementation\ncode_negone(::Type{T}) where {T<:AbstractUnsigned} = nothing\n\n# Universal operations with signedness-dependent behavior\nexp_bias(::Type{T}) where {T<:AbstractSigned{Bits, SigBits}} = 2^(Bits - SigBits - 1)\nexp_bias(::Type{T}) where {T<:AbstractUnsigned{Bits, SigBits}} = 2^(Bits - SigBits)","category":"page"},{"location":"reference/types/#Domain-Specific-Specialization","page":"Type System","title":"Domain-Specific Specialization","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"Extended vs. finite domain differences require specialized handling:","category":"page"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"# Infinity counts by domain\nnInfs(::Type{<:AkoSignedFinite}) = 0\nnInfs(::Type{<:AkoSignedExtended}) = 2\nnInfs(::Type{<:AkoUnsignedFinite}) = 0\nnInfs(::Type{<:AkoUnsignedExtended}) = 1","category":"page"},{"location":"reference/types/#Compile-Time-Optimization","page":"Type System","title":"Compile-Time Optimization","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"The parametric type system enables extensive compile-time precomputation, eliminating runtime overhead for format introspection:","category":"page"},{"location":"reference/types/#Static-Bit-Computations","page":"Type System","title":"Static Bit Computations","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"# These resolve to constants during compilation\nconst SF4P2_BITS = nbits(SignedFinite{4,2,Float64,UInt8})     # 4\nconst SF4P2_EXP_BITS = nbits_exp(SignedFinite{4,2,Float64,UInt8}) # 2\nconst SF4P2_VALUES = nvalues(SignedFinite{4,2,Float64,UInt8})   # 16","category":"page"},{"location":"reference/types/#Loop-Unrolling-Opportunities","page":"Type System","title":"Loop Unrolling Opportunities","text":"","category":"section"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"# Enables aggressive loop optimization\nfunction process_all_codes(::Type{T}) where {T<:AbstractAIFloat}\n    # Loop bound known at compile time\n    for code in 0:(nvalues(T)-1)\n        # Process each encoding...\n    end\nend","category":"page"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"This design philosophy maximizes both performance and programmer ergonomics through careful exploitation of Julia's type system capabilities.","category":"page"},{"location":"reference/types/","page":"Type System","title":"Type System","text":"","category":"page"},{"location":"reference/constructors/#Constructor-Reference","page":"Constructors","title":"Constructor Reference","text":"","category":"section"},{"location":"reference/constructors/#Primary-Constructor","page":"Constructors","title":"Primary Constructor","text":"","category":"section"},{"location":"reference/constructors/","page":"Constructors","title":"Constructors","text":"The main entry point for creating AIFloat format instances. Supports both parametric specification and abstract type-based construction.","category":"page"},{"location":"reference/constructors/#Parameter-Based-Construction","page":"Constructors","title":"Parameter-Based Construction","text":"","category":"section"},{"location":"reference/constructors/","page":"Constructors","title":"Constructors","text":"AIFloat(bitwidth::Int, precision::Int, signedness::Symbol, domain::Symbol)","category":"page"},{"location":"reference/constructors/","page":"Constructors","title":"Constructors","text":"Parameters:","category":"page"},{"location":"reference/constructors/","page":"Constructors","title":"Constructors","text":"bitwidth: Total number of bits (3 ≤ bitwidth ≤ 15)\nprecision: Significand bits including implicit bit (1 ≤ precision ≤ bitwidth)\nsignedness: Either :signed or :unsigned\ndomain: Either :finite or :extended","category":"page"},{"location":"reference/constructors/","page":"Constructors","title":"Constructors","text":"Examples: ```julia","category":"page"},{"location":"reference/constructors/#4-bit-signed","page":"Constructors","title":"4-bit signed","text":"","category":"section"},{"location":"reference/constructors/","page":"Constructors","title":"Constructors","text":"","category":"page"},{"location":"glossary/#Glossary","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"glossary/#A","page":"Glossary","title":"A","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"AbstractAIFloat : The root abstract type for all AI floating-point formats, parameterized by bitwidth, significand bits, and signedness.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Augmented Binary Rationals : The mathematical foundation of AIFloats: finite binary rationals extended with NaN for undefined operations, denoted mathbbB^diamond = (mathbbQ_2^* cup textNaN).","category":"page"},{"location":"glossary/#B","page":"Glossary","title":"B","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Bias (Exponent) : The constant subtracted from the raw exponent field to produce signed exponent values. Calculated as 2^(textexp_bits - 1) - textis_signed.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Bit Budget : The allocation of available bits among sign, exponent, and significand fields, subject to format-specific constraints.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Bitwidth : The total number of bits in a floating-point representation, ranging from 3 to 15 bits in AIFloats.","category":"page"},{"location":"glossary/#C","page":"Glossary","title":"C","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Code : The integer encoding corresponding to a floating-point value, stored as UInt8 or UInt16 depending on bitwidth.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Code-Value Correspondence : The bijective mapping between integer encodings and floating-point values maintained by each AIFloat format.","category":"page"},{"location":"glossary/#D","page":"Glossary","title":"D","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Domain (Extended/Finite) : The value domain classification:","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Finite: Real numbers ∪ {NaN}\nExtended: Real numbers ∪ {NaN, ±∞} or {NaN, +∞}","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Dynamic Range : The ratio between the largest and smallest representable magnitudes in a format.","category":"page"},{"location":"glossary/#E","page":"Glossary","title":"E","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Encoding Sequence : The ordered sequence of integer codes [0x00, 0x01, ..., 0xFF] corresponding to a format's value sequence.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Exception-Free Arithmetic : The design principle ensuring no computational exceptions (NaN generation, infinity overflow) occur during normal operations.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Exponent Field : The bit field encoding the power-of-two scaling factor, with width determined by remaining bits after significand allocation.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Extended Binary Rationals : Binary rational numbers augmented with infinities: mathbbQ_2^* = mathbbQ_2 cup pminfty.","category":"page"},{"location":"glossary/#F","page":"Glossary","title":"F","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Format Family : The four-way classification of AIFloat types:","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"SignedFinite, SignedExtended, UnsignedFinite, UnsignedExtended","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Fractional Bits : The explicit significand bits excluding the implicit leading bit, equal to precision - 1.","category":"page"},{"location":"glossary/#I","page":"Glossary","title":"I","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"IEEE P3109 : The draft IEEE standard for arithmetic formats for machine learning, providing formal specifications for reduced-precision arithmetic.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Implicit Bit : The leading significand bit (0 for subnormals, 1 for normals) that is not explicitly stored but assumed based on exponent value.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Index : Julia's 1-based array position corresponding to a code's location in the value sequence.","category":"page"},{"location":"glossary/#M","page":"Glossary","title":"M","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Magnitude Foundation : The base sequence of non-negative values before sign extension, generated through significand-exponent scaling.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Mixed Precision : The use of different AIFloat formats for different components within a single computation.","category":"page"},{"location":"glossary/#N","page":"Glossary","title":"N","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Normal Values : Floating-point values with implicit leading bit 1, following the pattern (1 + textfraction) times 2^textunbiased_exponent.","category":"page"},{"location":"glossary/#P","page":"Glossary","title":"P","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Prenormal Region : The value domain containing zero plus all subnormal magnitudes, totaling 2^(textprecision - 1) values.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Precision : The total number of significand bits including the implicit leading bit, determining the granularity of representable values.","category":"page"},{"location":"glossary/#Q","page":"Glossary","title":"Q","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Quantization : The process of mapping continuous or higher-precision values to the discrete set of AIFloat-representable values.","category":"page"},{"location":"glossary/#S","page":"Glossary","title":"S","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Significand : The fractional part of a floating-point representation, consisting of an implicit bit plus fractional bits.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Signedness : The format property determining whether negative values are representable (:signed) or only non-negative values (:unsigned).","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Stochastic Rounding : A probabilistic rounding mode where the selection between adjacent representable values depends on the input's relative distance.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Subnormal Values : Floating-point values with implicit leading bit 0, providing gradual underflow near zero with pattern textfraction times 2^textexp_min.","category":"page"},{"location":"glossary/#T","page":"Glossary","title":"T","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Table Lookup : The computational approach using precomputed arrays for ultra-fast evaluation of unary and binary functions on small formats.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Type-Level Computation : The technique of performing calculations at compile time using Julia's type system, eliminating runtime overhead.","category":"page"},{"location":"glossary/#U","page":"Glossary","title":"U","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"ULP (Unit in Last Place) : The spacing between consecutive representable values, varying by magnitude due to exponential scaling.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Unbiased Exponent : The true exponent value after bias subtraction, ranging symmetrically around zero.","category":"page"},{"location":"glossary/#V","page":"Glossary","title":"V","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Value Sequence : The ordered array of floating-point values corresponding to sequential integer encodings, forming the format's canonical representation.","category":"page"},{"location":"glossary/#Z","page":"Glossary","title":"Z","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Zero Encoding : The canonical representation of zero, always encoded as 0b0...0 across all AIFloat formats.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"","category":"page"},{"location":"implementation/#Implementation-Notes","page":"Implementation Notes","title":"Implementation Notes","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"This section documents key implementation decisions, performance considerations, and technical details that inform effective usage of AIFloats.jl.","category":"page"},{"location":"implementation/#Memory-Management-Strategy","page":"Implementation Notes","title":"Memory Management Strategy","text":"","category":"section"},{"location":"implementation/#Cache-Aligned-Allocation","page":"Implementation Notes","title":"Cache-Aligned Allocation","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"AIFloats employs cache-aligned memory allocation to optimize memory access patterns:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"# From AlignedAllocs.jl integration\nfloats = memalign_clear(Float64, nvalues)\ncodes = memalign_clear(UInt8, nvalues)\n\n# Ensures alignment to L1 cache boundaries (typically 64 bytes)\n@assert alignment(floats) >= 64\n@assert ispow2(alignment(floats))","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"Benefits:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"Eliminates cache line splits for sequential access\nImproves vectorization efficiency in modern CPUs\nReduces memory bandwidth requirements for bulk operations","category":"page"},{"location":"implementation/#Dual-Array-Architecture","page":"Implementation Notes","title":"Dual Array Architecture","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"The fundamental design stores both floating-point values and integer encodings:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"struct SignedFinite{bits, sigbits, T<:AbstractFloat, S<:Unsigned}\n    floats::Vector{T}  # Canonical value sequence\n    codes::Vector{S}   # Corresponding encodings\nend","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"Rationale:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"Direct computation: Operate on decoded floating-point values\nTable lookup: Ultra-fast encoding/decoding via array indexing\nMemory locality: Related data structures stored contiguously","category":"page"},{"location":"implementation/#Storage-Type-Selection","page":"Implementation Notes","title":"Storage Type Selection","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"Automatic storage type selection balances precision against memory efficiency:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"typeforfloat(bits) = bits ≤ 8 ? Float64 : (bits ≤ 11 ? Float64 : Float128)\ntypeforcode(bits) = bits ≤ 8 ? UInt8 : UInt16","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"Bitwidth Float Storage Code Storage Rationale\n3-8 Float64 UInt8 Standard precision adequate\n9-11 Float64 UInt16 Extended exponent range\n12-15 Float128 UInt16 High precision requirements","category":"page"},{"location":"implementation/#Value-Sequence-Generation","page":"Implementation Notes","title":"Value Sequence Generation","text":"","category":"section"},{"location":"implementation/#Extended-Precision-Pipeline","page":"Implementation Notes","title":"Extended Precision Pipeline","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"Value sequence generation employs extended precision to ensure bit-exact reproducibility:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"function magnitude_foundation_seq(::Type{T}) where {T<:AbstractAIFloat}\n    # Stage 1: Compute in extended precision\n    significands = significand_magnitudes(T)\n    exp_values = map(x -> Float128(2)^x, exp_unbiased_magnitude_strides(T))\n    \n    # Stage 2: Scale with maximum precision\n    scaled_magnitudes = significands .* exp_values\n    \n    # Stage 3: Convert to working precision\n    return map(typeforfloat(nbits(T)), scaled_magnitudes)\nend","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"Critical Implementation Details:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"Uses Float128 or BigFloat for intermediate computations when Float64 precision insufficient\nHandles edge cases where 2^exponent underflows to zero\nMaintains mathematical consistency across platforms","category":"page"},{"location":"implementation/#Significance-Quantization","page":"Implementation Notes","title":"Significance Quantization","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"The significand generation follows IEEE-style quantization:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"function prenormal_magnitude_steps(::Type{T}) where {T<:AbstractAIFloat}\n    nprenormal = nmagnitudes_prenormal(T)\n    step_size = 1 / typeforfloat(T)(nprenormal)\n    return (0:(nprenormal-1)) * step_size\nend\n\nfunction normal_magnitude_steps(::Type{T}) where {T<:AbstractAIFloat}\n    nprenormal = nmagnitudes_prenormal(T)\n    # Normal values: [1.0, 2.0) in significand space\n    return (nprenormal:(2*nprenormal-1)) / typeforfloat(T)(nprenormal)\nend","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"This approach ensures exact representability of key values (0, 1, powers of 2) while maintaining uniform quantization within each regime.","category":"page"},{"location":"implementation/#Dispatch-Optimization","page":"Implementation Notes","title":"Dispatch Optimization","text":"","category":"section"},{"location":"implementation/#Compile-Time-Resolution","page":"Implementation Notes","title":"Compile-Time Resolution","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"The parametric type system enables aggressive compile-time optimization:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"# These resolve to constants during compilation\n@inline nbits(::Type{<:AbstractAIFloat{Bits}}) where {Bits} = Bits\n@inline nvalues(::Type{<:AbstractAIFloat{Bits}}) where {Bits} = 2^Bits\n\n# Enables loop unrolling and constant propagation\nfunction process_all_values(::Type{T}) where {T<:AbstractAIFloat}\n    # Loop bound known at compile time\n    for i in 1:nvalues(T)\n        # Compiler can fully unroll for small formats\n    end\nend","category":"page"},{"location":"implementation/#Method-Specialization-Strategy","page":"Implementation Notes","title":"Method Specialization Strategy","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"The dispatch hierarchy minimizes runtime overhead through careful specialization:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"# Signedness dispatch avoids runtime conditionals\nexp_bias(::Type{<:AbstractSigned{Bits, SigBits}}) where {Bits, SigBits} = \n    2^(Bits - SigBits - 1)\nexp_bias(::Type{<:AbstractUnsigned{Bits, SigBits}}) where {Bits, SigBits} = \n    2^(Bits - SigBits)\n\n# Domain dispatch handles special values efficiently\nnInfs(::Type{<:AkoSignedFinite}) = 0\nnInfs(::Type{<:AkoSignedExtended}) = 2","category":"page"},{"location":"implementation/#Performance-Characteristics","page":"Implementation Notes","title":"Performance Characteristics","text":"","category":"section"},{"location":"implementation/#Complexity-Analysis","page":"Implementation Notes","title":"Complexity Analysis","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"Operation Time Complexity Space Complexity Notes\nFormat construction O(2^bits) O(2^bits) One-time cost\nValue lookup O(1) O(1) Array indexing\nCode lookup O(log n) O(1) Binary search\nFormat introspection O(1) O(1) Compile-time resolution","category":"page"},{"location":"implementation/#Optimization-Thresholds","page":"Implementation Notes","title":"Optimization Thresholds","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"Different computational strategies optimal for different format sizes:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"# Small formats: Complete lookup tables\nis_table_friendly(::Type{T}) where {T<:AbstractAIFloat} = nvalues(T) ≤ 64\n\n# Medium formats: Selective table acceleration\nis_hybrid_optimal(::Type{T}) where {T<:AbstractAIFloat} = 64 < nvalues(T) ≤ 256\n\n# Large formats: Direct computation preferred\nis_direct_optimal(::Type{T}) where {T<:AbstractAIFloat} = nvalues(T) > 256","category":"page"},{"location":"implementation/#Numerical-Precision-Considerations","page":"Implementation Notes","title":"Numerical Precision Considerations","text":"","category":"section"},{"location":"implementation/#Catastrophic-Cancellation-Avoidance","page":"Implementation Notes","title":"Catastrophic Cancellation Avoidance","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"Critical numerical computations employ compensated arithmetic:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"function compensated_exponent_scaling(base_value, exponent)\n    # Use Dekker's algorithm for accurate scaling\n    if abs(exponent) > 300  # Potential over/underflow\n        # Split exponent to avoid intermediate overflow\n        exp_hi = exponent ÷ 2\n        exp_lo = exponent - exp_hi\n        return (base_value * (2.0^exp_hi)) * (2.0^exp_lo)\n    else\n        return base_value * (2.0^exponent)\n    end\nend","category":"page"},{"location":"implementation/#ULP-Accurate-Construction","page":"Implementation Notes","title":"ULP-Accurate Construction","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"The value sequence generation maintains ULP-level accuracy guarantees:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"function verify_ulp_accuracy(format::AbstractAIFloat)\n    values = floats(format)\n    \n    # Check monotonicity (excluding NaN/Inf)\n    finite_indices = findall(isfinite, values)\n    finite_values = values[finite_indices]\n    @assert issorted(finite_values)\n    \n    # Verify no duplicate finite values\n    @assert allunique(finite_values)\n    \n    # Check special value placement\n    @assert iszero(values[1])  # Zero at position 1\n    @assert isnan(values[end]) # NaN at final position\nend","category":"page"},{"location":"implementation/#Integration-with-Julia-Ecosystem","page":"Implementation Notes","title":"Integration with Julia Ecosystem","text":"","category":"section"},{"location":"implementation/#AbstractFloat-Interface-Compliance","page":"Implementation Notes","title":"AbstractFloat Interface Compliance","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"AIFloats integrate seamlessly with Julia's numeric tower:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"# Standard interface methods\nBase.precision(::Type{<:AbstractAIFloat{Bits, SigBits}}) where {Bits, SigBits} = SigBits\nBase.eps(x::AbstractAIFloat) = eps(typeof(x))\nBase.isnan(format::AbstractAIFloat, code::Unsigned) = iscode_nan(format, code)","category":"page"},{"location":"implementation/#Aqua.jl-Compatibility","page":"Implementation Notes","title":"Aqua.jl Compatibility","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"The package addresses method ambiguities identified by Aqua.jl:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"# Explicit disambiguation for RoundingMode constructors\nUnsignedFinite{bits, sigbits, T, S}(::Real, ::RoundingMode) where {S, T, sigbits, bits} = \n    false","category":"page"},{"location":"implementation/#Broadcasting-Support","page":"Implementation Notes","title":"Broadcasting Support","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"AIFloats support Julia's broadcasting infrastructure for element-wise operations:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"# Enable broadcasting over format instances\nBase.broadcastable(x::AbstractAIFloat) = Ref(x)\n\n# Custom broadcast rules for format-aware operations\nfunction Base.broadcasted(::typeof(quantize), values::AbstractArray, format::AbstractAIFloat)\n    return map(v -> quantize_single(v, format), values)\nend","category":"page"},{"location":"implementation/#Future-Optimization-Opportunities","page":"Implementation Notes","title":"Future Optimization Opportunities","text":"","category":"section"},{"location":"implementation/#SIMD-Vectorization","page":"Implementation Notes","title":"SIMD Vectorization","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"Potential SIMD acceleration for bulk operations:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"# Vectorized quantization for arrays\nfunction simd_quantize(values::Vector{Float32}, format::AbstractAIFloat)\n    # Use SIMD.jl for parallel nearest-neighbor search\n    # Leverage CPU vector units for 4x-8x speedup\nend","category":"page"},{"location":"implementation/#GPU-Integration","page":"Implementation Notes","title":"GPU Integration","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"AIFloats design facilitates GPU acceleration:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"# CUDA.jl integration for GPU-based quantization\nfunction cuda_quantize(values::CuArray, format::AbstractAIFloat)\n    # Transfer lookup tables to GPU memory\n    # Parallel quantization across CUDA cores\nend","category":"page"},{"location":"implementation/#Custom-Instruction-Integration","page":"Implementation Notes","title":"Custom Instruction Integration","text":"","category":"section"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"Future hardware support for reduced-precision arithmetic:","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"# Integration with custom AI accelerator instructions\nfunction hardware_quantize(values, format)\n    # Direct hardware instruction for format conversion\n    # Zero-overhead quantization in AI accelerators\nend","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"The implementation balances mathematical rigor, computational efficiency, and integration compatibility to provide a robust foundation for reduced-precision arithmetic in machine learning applications.","category":"page"},{"location":"implementation/","page":"Implementation Notes","title":"Implementation Notes","text":"","category":"page"},{"location":"#AIFloats.jl","page":"Home","title":"AIFloats.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fast floating-point formats for deep learning: A family portrait","category":"page"},{"location":"","page":"Home","title":"Home","text":"AIFloats.jl implements a comprehensive family of AI-optimized floating-point formats with bitwidths from 3 to 15 bits, designed specifically for deep learning applications. This package provides formally verified implementations following the IEEE P3109 standard for reduced-precision arithmetic.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Four Format Families: Signed/Unsigned × Finite/Extended configurations\nVariable Precision: 3-15 bit representations with configurable significand widths\nException-Free Design: No NaN propagation or infinity exceptions during computation\nFormally Verified: Conforming to IEEE P3109 standard specifications\nPerformance Optimized: Cache-aligned memory allocation and lookup table acceleration\nComprehensive API: Over 100 functions for format characterization and manipulation","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using AIFloats\n\n# Create a 4-bit unsigned finite format with 2-bit precision\nuf4p2 = AIFloat(4, 2, :unsigned, :finite)\n\n# Access the value and encoding sequences\nfloats(uf4p2)  # [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, NaN]\ncodes(uf4p2)   # [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07]\n\n# Query format properties\nnbits(uf4p2)        # 4\nnbits_sig(uf4p2)    # 2\nnvalues(uf4p2)      # 8\nis_finite(uf4p2)    # true\nis_unsigned(uf4p2)  # true","category":"page"},{"location":"#Format-Taxonomy","page":"Home","title":"Format Taxonomy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"graph TD\n    A[AbstractAIFloat] --> B[AbstractSigned]\n    A --> C[AbstractUnsigned]\n    B --> D[SignedFinite<br/>Finite ∪ NaN]\n    B --> E[SignedExtended<br/>Finite ∪ NaN ∪ ±∞]\n    C --> F[UnsignedFinite<br/>Finite ∪ NaN]\n    C --> G[UnsignedExtended<br/>Finite ∪ NaN ∪ +∞]","category":"page"},{"location":"#Mathematical-Foundation","page":"Home","title":"Mathematical Foundation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AIFloats represent augmented binary rational numbers mathbbB^diamond = (mathbbQ_2^* cup textNaN), where:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finite values: Scaled significands with biased exponents\nPrenormal regime: Zero plus subnormal magnitudes (significand × minimum exponent)\nNormal regime: (1 + textfractional) times 2^textunbiased exponent\nExtended formats: Include infinities for overflow handling\nNaN encoding: Deterministic placement opposite zero encoding","category":"page"},{"location":"#Design-Philosophy","page":"Home","title":"Design Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"\"There are no Exceptional States - the flow of learning, training and inference is unbroken\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Unlike traditional IEEE 754 arithmetic, AIFloats eliminate computational exceptions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"No NaN propagation during normal operations\nNo infinity generation from finite operands\nDeterministic overflow behavior with saturation\nCache-friendly memory layouts for table-driven computation","category":"page"},{"location":"#Package-Ecosystem","page":"Home","title":"Package Ecosystem","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AIFloats.jl: Core format definitions and utilities\nAlignedAllocs.jl: Cache-aligned memory allocation\nAIFloatTables.jl: Lookup table generation for fast operations","category":"page"},{"location":"#Standards-Compliance","page":"Home","title":"Standards Compliance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AIFloats.jl implements the IEEE P3109 Standard for Arithmetic Formats for Machine Learning, the first formally verified floating-point standard. This ensures:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Specification Conformance: All operations match formal specifications\nBehavioral Predictability: Results meet informed expectations\nException Safety: No unexpected NaN or infinity generation","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"AIFloats\")","category":"page"},{"location":"#Related-Work","page":"Home","title":"Related Work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IEEE 754-2019: Traditional floating-point standard\nIEEE P3109: AI-optimized arithmetic standard (in development)\nBFloat16, FP8: Hardware-specific reduced precision formats","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
