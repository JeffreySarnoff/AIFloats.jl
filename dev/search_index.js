var documenterSearchIndex = {"docs":
[{"location":"families/","page":"Float Families","title":"Float Families","text":"For each member of this family of floating-point formats, this package provides the encoding and paired value sequence. There are two sorts of ML floats, Signed and Unsigned. There are two kinds of each, Finite and Extended. All have one NaN value and one Zero value. Extended kinds have a [signed] infinity, while Finite kinds do not.","category":"page"},{"location":"families/","page":"Float Families","title":"Float Families","text":"Signed\nFinite\nExtended\nUnsigned\nFinite\nExtended","category":"page"},{"location":"families/","page":"Float Families","title":"Float Families","text":"Sort Kind 1 NaN 1 Zero Infinity Family Generalized Name\nSigned Finite yes yes N/A SFinite sùöèBinary bitwidth P precision\nSigned Extended yes yes ¬±Inf SExtended seBinary bitwidth P precision\nUnsigned Finite yes yes N/A UFinite uùöèBinary bitwidth P precision\nUnsigned Extended yes yes +Inf UExtended ueBinary bitwidth P precision","category":"page"},{"location":"families/","page":"Float Families","title":"Float Families","text":"The bitwidths of the members of each family may be as low as 2 and as large as 15. The admissible precisions range from 1 through bitwidth-1.  ","category":"page"},{"location":"families/","page":"Float Families","title":"Float Families","text":"All value sequences have subnormals except for precisions of 1.","category":"page"},{"location":"families/","page":"Float Families","title":"Float Families","text":"","category":"page"},{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#AIFloats.AIFloats","page":"Reference","title":"AIFloats.AIFloats","text":"AIFloats\n\nexamples\n\n```     UF42   = MLFloats( 4,  2, IsUnsigned, IsFinite)     UE64   = MLFloats( 6,  4, IsUnsigned, IsExtended)     SE84   = MLFloats( 8,  4, IsSigned,   IsExtended)     SE1512 = MLFloats(15, 12, IsSigned,   IsExtended)\n\nseBinary84_encodings = codes(SE84)\nseBinary84_valuation = floats(SE84)\n\n````\n\n\n\n\n\n","category":"module"},{"location":"95-reference/#AIFloats.CODE","page":"Reference","title":"AIFloats.CODE","text":"CODE\n\nThe built-in Unsigned Integer types available for encodings.\n\nUInt8 for bitwidths <= 8\nUInt16 for bitwidths > 8\n\nsee also FLOAT\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#AIFloats.CODE_TYPES","page":"Reference","title":"AIFloats.CODE_TYPES","text":"CODE\n\nThe built-in Unsigned Integer types available for encodings.\n\nUInt8 for bitwidths <= 8\nUInt16 for bitwidths > 8\n\nsee also FLOAT\n\n\n\n\n\n","category":"constant"},{"location":"95-reference/#AIFloats.FLOAT_TYPES","page":"Reference","title":"AIFloats.FLOAT_TYPES","text":"FLOAT\n\nThe built-in floating-point types available for valuations.\n\nFloat32 for bitwidths <= 8\nFloat64 for bitwidths > 8\n\nsee also CODE\n\n\n\n\n\n","category":"constant"},{"location":"95-reference/#AIFloats.FLOAT","page":"Reference","title":"AIFloats.FLOAT","text":"FLOAT\n\nThe built-in floating-point types available for valuations.\n\nFloat32 for bitwidths <= 8\nFloat64 for bitwidths > 8\n\nsee also CODE\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#AIFloats.compacttype","page":"Reference","title":"AIFloats.compacttype","text":"compacttype(::Type{T}) where {T<:AbstractAIFloat{Bits, SigBits}}\n\nSignedExtendedFloat{8, 5, Float64, UInt8} ‚§á SignedExtendedFloat{8, 5}\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.index_to_code","page":"Reference","title":"AIFloats.index_to_code","text":"index_to_code(bits, index)\n\nconvert the Julia index x into a P3109 encoding value as a UInt8|16\n\n(8, 256) ‚Ü¶ 0xff\n(9, 256) ‚Ü¶ 0x00ff\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.index_to_offset","page":"Reference","title":"AIFloats.index_to_offset","text":"indextooffset(x)\n\nconvert the Julia index x into a P3109 offset as a UInt16\n\n(0x040) ‚Ü¶ 0x0039\nin 0-based languages, this is a do nothing operation\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.offset_to_index","page":"Reference","title":"AIFloats.offset_to_index","text":"offset_to_index(x)\n\nconvert the P3109 encoding x into a Julia index as an UInt16\n\n(0x39) ‚Ü¶ 0x0040\n(255) ‚Ü¶ 0x01\nin 0-based languages, this is a do nothing operation\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.typeforcode","page":"Reference","title":"AIFloats.typeforcode","text":"typeforcode(bitwidth)\n\nThe bitstype to be used for encoding values of bitwidth\n\nIt is an unchecked error to set bitwidth outside BitsMin..BitsMax\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#AIFloats.typeforfloat","page":"Reference","title":"AIFloats.typeforfloat","text":"typeforfloat(bitwidth)\n\nThe bitstype to be used for storing values of bitwidth\n\nIt is an unchecked error to set bitwidth outside BitsMin..BitsMax\n\n\n\n\n\n","category":"function"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"rationalseq/","page":"-","title":"-","text":"https://chatgpt.com/g/g-kZ0eYXlJe-scholar-gpt/c/67ef77b5-df50-8005-b87b-3dfd7ca20a85 a is there a name for the sequence (K > 2): 1/K, 2/K, .., (K-2)/K, (K-1)/K","category":"page"},{"location":"rationalseq/","page":"-","title":"-","text":"If you include 0 and 1, it's usually called a uniform grid over [0,1] with K+1 points.","category":"page"},{"location":"rationalseq/","page":"-","title":"-","text":"Uniform Rational Subdivision (excluding endpoints) It comes from dividing the unit interval [0,1] into K equal parts and then excluding 0 and 1:     [0,1] with K+1 points:","category":"page"},{"location":"rationalseq/","page":"-","title":"-","text":"Yes! The sequence you're describing is a uniformly spaced sequence of rational numbers between  1/K .. (K‚àí1)/K, with step size 1/K, excluding the endpoints 0 and 1.","category":"page"},{"location":"rationalseq/","page":"-","title":"-","text":"There isn't a widely-used special name for this exact sequence in general mathematical literature, but it's most commonly understood and referred to as:","category":"page"},{"location":"rationalseq/","page":"-","title":"-","text":"üîπ Uniform Rational Subdivision (excluding endpoints) It comes from dividing the unit interval  [0,1] into ùêæ (K equal parts and then excluding 0 and 1)","category":"page"},{"location":"rationalseq/","page":"-","title":"-","text":"","category":"page"},{"location":"sequence/","page":"The foundational sequence","title":"The foundational sequence","text":"this development immediately pertains to binaryKpP, where P ‚àà {2..K-1}.[a]","category":"page"},{"location":"sequence/","page":"The foundational sequence","title":"The foundational sequence","text":"each finite value in the [nonnegative portion of a] value sequence is a arithmetic composition of three components:","category":"page"},{"location":"sequence/","page":"The foundational sequence","title":"The foundational sequence","text":"a trailing significand (a nonnegative integer in the range [0, 2^P-1])\nthis is a fractional binary value\nan implicit leading bit {0b0, 0b1}\nthe finite value is subnormal when the implicit bit is 0b0 and the trailing significand is non-zero\nthe finite value is normal when the implicit bit is 1b1, whatever the trailing significand may be.\nan exponent (stored as a nonnegative integer in the range [0, 2^(K-P)-1])\nthe exponent is biased (all values >= 0)\nto recover its constructive value, subtract the bias (2^(K-P-1)-1) from the biased value.\nthe exponent acts multiplicatively as 2^exponent","category":"page"},{"location":"sequence/","page":"The foundational sequence","title":"The foundational sequence","text":"each finite value in the [nonnegative portion of a] value sequence is determined with:     value = (2^unbiased_exponent) * (implicit_bit + (trailing_significand_bits / 2^P))","category":"page"},{"location":"sequence/","page":"The foundational sequence","title":"The foundational sequence","text":"value = (2^unbiased_exponent) * (implicit_bit) + (2^unbiased_exponent) * (trailing_significand / 2^P))\nvalue = (2^unbiased_exponent) * (implicit_bit) + ((2^unbiased_exponent)/2^P) * (trailing_significand / 1))\nvalue = (2^unbiased_exponent) * (implicit_bit) + (2^(unbiased_exponent-P) * trailing_significand)\n\nsubnormal value = (2^unbiased_exponent) * (0b0) + (2^(unbiased_exponent-P) * trailing_significand)\nsubnormal value = (2^(unbiased_exponent-P) * trailing_significand)\nsubnormal value = (2^(unbiased_exponent_min) * trailing_significand)\n\nnormal value = (2^unbiased_exponent) * (0b1) + (2^(unbiased_exponent-P) * trailing_significand)\nnormal value = (2^unbiased_exponent) + (2^(unbiased_exponent-P) * trailing_significand)\n\nnormal_value = (2^unbiased_exponent) + subnormal_value","category":"page"},{"location":"sequence/","page":"The foundational sequence","title":"The foundational sequence","text":"[a]: Floating-point value sequences that have no subnormal values are eccentric.","category":"page"},{"location":"sequence/","page":"The foundational sequence","title":"The foundational sequence","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"Unit Fractions 1/K and (K‚Äì1)/K in Number Theory Introduction Unit fractions ‚Äì fractions with numerator 1 ‚Äì are the simplest rational numbers, and their complements of the form (K-1)K (just one unit fraction shy of 1) also yield interesting properties. For example, 1K and (K-1)K = 1 - 1K are obviously related (their sum is 1), but this simple relationship belies a rich structure. These forms appear throughout number theory, from ancient Egyptian fraction notation to modern conjectures about rational Diophantine equations. In this report, we explore the properties of 1K and (K-1)K, how they relate to general rational numbers, and their role in various number-theoretic contexts. We will see historical methods of representing fractions using such terms, patterns and identities involving these fractions, and connections to topics like modular arithmetic, Egyptian fractions, and Diophantine equations. Examples and theorems from both classical and contemporary mathematics will illustrate the significance of these simple fractions. Historical Context: Egyptian Fractions","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"K=7 1/K == 1/(K+1) + 1/(K * (K+1))","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"Figure: A portion of the Rhind Mathematical Papyrus (c. 1550 BC), which includes tables decomposing fractions like 2n into unit fractions‚Äã EN.WIKIPEDIA.ORG . The ancient Egyptians expressed rational numbers as sums of distinct unit fractions (with a few exceptions for certain forms like tfrac23). In their notation, 12 13 14 dots were written with special hieroglyphic symbols, and any fraction tfracab with ab was represented as a sum of such unit fractions (an Egyptian fraction). Notably, they allowed a couple of non-unit fractions as special cases: they had symbols for tfrac23 and tfrac34‚Äã EN.WIKIPEDIA.ORG . In fact, when a fraction larger than 12 needed to be expressed, scribes would often subtract one of these standard complements (like 23 or 34) and then express the remainder as a sum of unit fractions‚Äã EN.WIKIPEDIA.ORG . For example, tfrac34 might be taken as a single summand (since tfrac34 = 1 - tfrac14 is one unit fraction short of 1), or tfrac23 as a summand (since tfrac23 = 1 - tfrac13). This shows that complements of unit fractions were an integral part of Egyptian representations. A famous example appears in the Rhind Mathematical Papyrus (also called the Ahmes Papyrus, ~1650 BC). The papyrus begins with a table decomposing fractions of the form 2n (for odd n from 3 to 101) into sums of distinct unit fractions‚Äã EN.WIKIPEDIA.ORG . For instance, it records frac215 = frac110 + frac130‚Äã EN.WIKIPEDIA.ORG . Remarkably, none of these decompositions used more than 4 terms ‚Äì even frac2101 is written as frac1101+frac1202+frac1303+frac1606‚Äã EN.WIKIPEDIA.ORG . After the 2n table, the papyrus gives examples of dividing numbers by 10, using 23 as a key part of the representation. It expresses, for example, frac710 = frac23 + frac130‚Äã EN.WIKIPEDIA.ORG . Here tfrac23 (which is (3-1)3) is used as a summand, showing the Egyptian preference for using (K-1)K forms like 23 to simplify the remainder. (Interestingly, in modern terms frac710 could be written more simply as frac12+frac15, but the Egyptian approach prioritized known unit-fraction tables and conventions.) These historical examples highlight that unit fractions 1K and their complements (K-1)K were building blocks of Egyptian mathematical notation‚Äã EN.WIKIPEDIA.ORG . The use of such fractions had practical motivations: for instance, frac58 = frac12 + frac18 meant that to divide 5 loaves among 8 people, each person could get half a loaf plus an eighth of a loaf‚Äã EN.WIKIPEDIA.ORG . Using unit fractions (and special cases like 23) made it easier to allocate and measure portions in a pre-decimal society. Representing Rational Numbers with Unit Fractions One of the fundamental number-theoretic facts about rational numbers is that any positive rational can be expressed as a sum of distinct unit fractions. In other words, for every fraction fracab (with 0ab) there exists an Egyptian fraction expansion: ùëé ùëè = 1 ùëõ 1","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùëõ 2","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"‚ãØ","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùëõ ùëò , b a ‚Äã  =  n  1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"n  2 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ‚Äã  +‚ãØ+  n  k ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ‚Äã  , where n_1 n_2 dots n_k are positive integers, all different. This was implicitly known to the Egyptians and was formally proven in modern terms by Fibonacci (Leonardo of Pisa). In his 1202 book Liber Abaci, Fibonacci described methods to convert any rational number into a sum of unit fractions‚Äã EN.WIKIPEDIA.ORG . One such method is the greedy algorithm: at each step, take the largest unit fraction not exceeding the remaining fraction. This algorithm (often called Fibonacci‚Äôs algorithm) will terminate with an Egyptian fraction representation‚Äã EN.WIKIPEDIA.ORG ‚Äã EN.WIKIPEDIA.ORG . For example, to expand frac45, the greedy method picks the largest unit fraction le 45, which is 12. Subtracting, 45 - 12 = 310. The largest unit fraction le 310 is 14. Subtracting, 310 - 14 = 120. Thus frac45 = frac12 + frac14 + frac120, an Egyptian fraction expansion‚Äã R-KNOTT.SURREY.AC.UK . (In fact, frac45 can be written more succinctly as frac12+frac15+frac110‚Äã R-KNOTT.SURREY.AC.UK  ‚Äì Egyptian fractions are not unique, and there are often many valid representations.) It is now a well-known theorem that every rational number has infinitely many Egyptian fraction representations‚Äã R-KNOTT.SURREY.AC.UK . Once you find one representation, you can generate more by an identity like 1 = frac12+frac13+frac16 (which is itself an Egyptian fraction)‚Äã R-KNOTT.SURREY.AC.UK : for example, substituting 1 = frac12+frac13+frac16 into any unit fraction frac1m yields frac1m = frac12m + frac13m + frac16m, introducing more terms but still all unit fractions‚Äã R-KNOTT.SURREY.AC.UK . This shows in principle that each rational number has infinitely many expansions‚Äã R-KNOTT.SURREY.AC.UK . Two simple identities involving our specific forms 1K and (K-1)K are worth noting. First, for any nge 2: Two-term expansion for 1n: displaystyle frac1n = frac1n+1 + frac1n(n+1). This identity can be verified by finding a common denominator: frac1n+1 + frac1n(n+1) = fracnn(n+1) + frac1n(n+1) = fracn+1n(n+1) = frac1n. For example, frac14 = frac15 + frac120, and frac110 = frac111 + frac1110. This provides a quick way to split any unit fraction into a sum of two smaller unit fractions. Second, from the earlier mentioned Egyptian identity for 1, we have: Three-term expansion for 1n: displaystyle frac1n = frac12n + frac13n + frac16n. This works because frac12n+frac13n+frac16n = frac3+2+16n = frac66n = frac1n. For example, frac17 = frac114+frac121+frac142. Interestingly, this shows that any single unit fraction 1K can be represented as a sum of three smaller unit fractions. The denominators (2K3K6K) in this formula are the first three positive divisors of 6K, and indeed 6 is a perfect number (equal to the sum of its divisors 1+2+3), which is why the numerators added up neatly to produce the identity‚Äã R-KNOTT.SURREY.AC.UK . The complements (K-1)K can also be expressed as Egyptian fractions. In fact, the Egyptians themselves treated some of these as special cases (23 and 34 they left as is‚Äã EN.WIKIPEDIA.ORG , but others like 45 56, etc., they would break down). As a general strategy, one can use the above identities to derive expansions for (K-1)K = 1 - frac1K. For example, using the two-term expansion of 1K, we get:  ùêæ ‚àí 1 ùêæ = 1 ‚àí 1 ùêæ = 1 ‚àí ( 1 ùêæ","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùêæ ( ùêæ","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ) ) = ùêæ ùêæ ‚àí 1 ùêæ","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ‚àí 1 ùêæ ( ùêæ","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ) . K K‚àí1 ‚Äã  =1‚àí  K 1 ‚Äã  =1‚àí(  K+1 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"K(K+1) 1 ‚Äã  )=  K K ‚Äã  ‚àí  K+1 1 ‚Äã  ‚àí  K(K+1) 1 ‚Äã  . Now fracKK = 1 can itself be written as an Egyptian fraction (for instance 1 = frac12+frac13+frac16 as given, or any other), so by substituting such an expansion for the 1 on the right-hand side, we can obtain an Egyptian fraction for (K-1)K. There isn‚Äôt a single canonical formula for all (K-1)K, but we can illustrate with a few examples: frac23 = frac12 + frac16 (a classic from the Rhind Papyrus)‚Äã R-KNOTT.SURREY.AC.UK . frac34 = frac12 + frac14 (trivial, since 34 already has denominator 4 as one term). frac45 = frac12 + frac15 + frac110 (one of several possibilities‚Äã R-KNOTT.SURREY.AC.UK ). frac67 = frac12 + frac13 + frac142 is one expansion (since 67 = 1 - 17 and we used the three-term expansion for 17 here). In general, representing (K-1)K may take two or more unit fractions depending on K. The ‚Äúgreedy algorithm‚Äù will always find some expansion. For instance, if we apply it to (K-1)K: the first term it picks is 12 (because (K-1)K  1 but is  12 for K2). After subtracting 12, the remainder is (K-1)K - 12 = (2K- (K-1))2K = (K+1)2K = frac12 + frac12K. So one gets (K-1)K = 12 + 12K. If K=3, this gives 23 = 12 + 16 as above; if K=5, it gives 45 = 12 + 110 (but we‚Äôd still have 45 - (12+110) = 15 left over, so actually the greedy algorithm would then add 15 to finish the job). In any case, the key takeaway is that 1K and 1 - 1K are not just reciprocals and complements in the trivial sense, but also act as fundamental pieces that can generate other rational numbers through Egyptian expansions. This is why historically they were tabulated and studied. Patterns in Modular Arithmetic and Repeating Decimals Unit fractions have a natural connection to modular arithmetic, especially when we consider their decimal (or other base) expansions. If K is coprime to 10, the decimal expansion of 1K will be repeating (non-terminating), and its repetend (the repeating block of digits) is intimately related to the multiplicative order of 10 modulo K. In fact, the length of the repeating cycle of 1K is the smallest positive integer d such that 10^d equiv 1 pmodK. For example, 17 = 0overline142857 has a repetend of length 6, and indeed 10^6 = 1000000 equiv 1 pmod7. The repeating digits 142857 are not random; they form what is known as a cyclic number. Multiplying 142857 by any number from 2 through 6 permutes its digits (e.g. 142857 times 2 = 285714), reflecting the fact that 27 37  67 produce cyclic permutations of the same repetend. In particular, frac67 = 0overline857142, which is exactly the ‚Äúcomplement‚Äù of 0overline142857 in the sense that 0overline142857 + 0overline857142 = 0overline999999 = 0999999ldots = 1. Generally, for a denominator K (coprime to the base), 1K and (K-1)K have repeating decimals that are complements of each other: digit by digit, they sum to 9 (in base 10). Another simple example: 13 = 0overline3 and 23 = 0overline6; indeed 3+6=9 in each repeating digit. Similarly, 111 = 0overline09 and 1011 = 0overline90. This pattern arises because (K-1)K = 1 - 1K, so its decimal expansion is the subtraction of 0overlinetext(repetend of 1K) from 1, which yields the 9‚Äôs complement repetend. In modular arithmetic terms, saying 10^d equiv 1 pmodK means K divides 10^d - 1, so 1K = fracA10^d - 1 for some integer A. Here 10^d-1 is a number like 99...9 (d digits of 9), and indeed A will be the integer formed by the repetend digits. For example, 17 = 142857999999 and 67 = 857142999999. This is a clear algebraic relation between a fraction and its repeating pattern. Beyond base-10 patterns, unit fractions also connect to general modular inverses. The number 1K (as a rational number) corresponds to the multiplicative inverse of K in the ring of integers modulo m, if gcd(Km)=1. For instance, 1K pmodp (for p prime not dividing K) is the unique number x such that Kx equiv 1 pmodp. This is essentially Fermat‚Äôs little theorem in action: one can show K^p-1 equiv 1 pmodp, hence K^p-2 equiv K^-1 pmodp, meaning x = K^p-2 is the residue corresponding to 1K. One interesting property here is that the sum of all such modular reciprocals in a prime field has a nice result: for a prime p2,  1","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 2","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 3","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"‚ãØ","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùëù ‚àí 1 ‚â° 0 ( m o d ùëù ) , 1+  2 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"3 1 ‚Äã  +‚ãØ+  p‚àí1 1 ‚Äã  ‚â°0(modp), when interpreted modulo p. This is because the set 1^-12^-1dots(p-1)^-1 is just a permutation of 12dotsp-1 modulo p. For example, mod 7: 1+12+13+14+15+16 equiv 1+4+5+2+3+6 = 21 equiv 0 pmod7. A far deeper result along these lines is Wolstenholme‚Äôs theorem (1862), which states that for any prime p3, the numerator of 1 + frac12 + cdots + frac1p-1 (when written in lowest terms) is divisible by p^2. This implies a congruence like 1 + frac12 + cdots + frac1p-1 equiv 0 pmodp^2 in a certain well-defined sense. Although not directly about 1K vs (K-1)K, Wolstenholme‚Äôs theorem underscores the special role of unit fractions summing up in modular arithmetic contexts. In summary, the forms 1K and (K-1)K show up in base-dependent patterns (like repeating decimals) and base-independent congruences (like properties of harmonic sums mod p). The complement pair 1K and (K-1)K often exhibit symmetry: one might call (K-1)K the ‚Äú9‚Äôs complement‚Äù of 1K in decimal, or in any base the analogous complement to the full reptend. Diophantine Equations and Egyptian Fraction Problems Expressions involving sums of unit fractions naturally lead to Diophantine equations. A classic example is the equation:  1 ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùë¶ = 1 ùëõ , x 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"y 1 ‚Äã  =  n 1 ‚Äã  , with xyn positive integers. Solving this is equivalent to finding an Egyptian fraction representation of 1n with two terms. Clearing denominators gives xy as a multiple of n:  1 ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùë¶ = 1 ùëõ ‚ÄÖ‚Ää ‚ü∫ ‚ÄÖ‚Ää ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"ùë¶ ùë• ùë¶ = 1 ùëõ ‚ÄÖ‚Ää ‚ü∫ ‚ÄÖ‚Ää ùë• ùë¶ = ùëõ ( ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"ùë¶ ) . x 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"y 1 ‚Äã  =  n 1 ‚Äã  ‚ü∫  xy x+y ‚Äã  =  n 1 ‚Äã  ‚ü∫xy=n(x+y). Rearrange to xy - nx - ny = 0 or (x-n)(y-n) = n^2. Thus solutions correspond to pairs of divisors of n^2. For each divisor d of n^2, one can set x-n = d and y-n = fracn^2d, yielding x = d+n and y = fracn^2d + n. This describes all solutions in positive integers. For example, with n=4: (x-4)(y-4)=16. The divisors of 16 give solutions like x-4=1 y-4=16 (so x=5 y=20) corresponding to 15+120=14; or x-4=2 y-4=8 (so x=6y=12) giving 16+112=14; or x-4=4y-4=4 (x=y=8) giving 18+18=14. That last solution uses a repeated unit fraction, which Egyptians would not allow, but mathematically it‚Äôs a valid solution of the equation. We see there are infinitely many representations of frac14 if we allowed repetition, but with the distinctness restriction we have finitely many (in this case two: 15+120 and 16+112) because (xy) and (yx) are considered the same representation for Egyptian fractions. This kind of analysis can be extended to equations with more terms, but it becomes much more complex. One famous problem in this vein is the Erd≈ës‚ÄìStraus conjecture (1948), which focuses on representations of frac4n as a sum of three unit fractions. The conjecture asserts that for every integer nge 2, there exist positive integers xyz such that:  4 ùëõ = 1 ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùë¶","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùëß . n 4 ‚Äã  =  x 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"y 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"z 1 ‚Äã  . In other words, frac4n has an Egyptian fraction expansion of length 3 (not necessarily with distinct denominators, though one can often make them distinct). Despite extensive effort, this conjecture remains unproven in full generality ‚Äì it is one of the longest-standing open problems about Egyptian fractions. It has been verified by computer for very large n (all n  10^17, as well as ‚Äúalmost all‚Äù n beyond that range)‚Äã EN.WIKIPEDIA.ORG , but a general proof is unknown. The conjecture is interesting because frac4n is (n-4)n plus a bit more complexity; why the numerator 4? It appears that 4 is the smallest integer where the property of always having a 3-term expansion might be hard to guarantee ‚Äì for frac3n, it‚Äôs known to be always possible with at most 3 terms, as we‚Äôll discuss next. Erd≈ës and Straus allowing repeated denominators means they considered solutions to 4n = 1x+1y+1z in positive integers without the distinctness condition (one could have x=y for instance). However, any solution with a repeat can be transformed into a solution with distinct terms (usually with more terms) by a transformation akin to the one by Takenouchi (1921)‚Äã EN.WIKIPEDIA.ORG . Empirical evidence strongly suggests Erd≈ës‚ÄìStraus is true ‚Äì no counterexample has been found up to very large n‚Äã EN.WIKIPEDIA.ORG  ‚Äì but it exemplifies how a simple question about unit fractions leads to deep difficulties. What about frac3n or other numerators? If n is a multiple of 3, frac3n is itself a unit fraction (=1(n3)), so the interesting cases are when 3nmid n. In 2000, Timothy Hagedorn proved that if n is not divisible by 3 and is odd, then frac3n can always be written as a sum of three distinct odd unit fractions‚Äã R-KNOTT.SURREY.AC.UK . For example, frac35 = frac12 + frac15 + frac110 (here one denominator is even, 10, so not all odd in this representation; Hagedorn‚Äôs theorem would guarantee a representation like frac35 = frac13 + frac14 + frac160 which uses only odd denominators except the 4‚Ä¶ perhaps a better example: frac37 = frac13 + frac111 + frac1231 uses odd denominators 3,11,231). If n is even and not a multiple of 3, frac3n also appears always to have a 3-term expansion (often even a 2-term one, e.g. frac310 = frac14+frac120). In fact, it‚Äôs known that every frac3n has a three-term expansion (with the possible exception of some even n that are powers of 2, which trivially don‚Äôt since frac32^k reduces to frac32^k and needs at least 3 terms). The case for frac5n and others grows progressively harder; there is no known simple criterion like the Erd≈ës‚ÄìStraus conjecture for 5, but computations suggest frac5n often needs at most 4 terms. Research continues into these kinds of problems, and they blend techniques from number theory, algebra, and computational search. Another intriguing result in this domain was the Erd≈ës‚ÄìGraham conjecture (proposed in 1980 by Paul Erd≈ës and Ronald Graham), which was solved in 2003. This was not about a single fraction but about partitioning the integers. It stated that if the positive integers greater than 1 are arbitrarily partitioned into finitely many subsets, one of those subsets will contain an ‚ÄúEgyptian fraction‚Äù sum that equals 1‚Äã EN.WIKIPEDIA.ORG . In plain terms: no matter how you color the integers in a fixed number of colors, you can always find a monochromatic set of numbers d_1dotsd_k such that frac1d_1+cdots+frac1d_k=1. This was proved by Ernie Croot in 2003‚Äã EN.WIKIPEDIA.ORG , confirming a deep fact about unit fractions summing to 1. Notice the sum to 1 can be seen as a special case of the complement idea: summing to 1 means you‚Äôve perfectly expressed 1 (which is NN for any N) as an Egyptian fraction. Indeed, expressing 1 itself as an Egyptian fraction has a tie to number theory: a number N is perfect if 1 + frac12 + cdots + frac1N-1 = 1 when restricting the sum to divisors of N. For example, 6 is perfect because 6 = 1+2+3, which yields 1 = 12 + 13 + 16. 28 is perfect (divisors 1+2+4+7+14=28) giving 1 = 12+14+17+114+128. More generally, primary pseudoperfect numbers are those that allow an Egyptian fraction of 1 that includes the number itself in the denominators. An example is 1806, which has the property 1806 = 2 times 3 times 7 times 43 divides something and indeed 1 = 12 + 13 + 17 + 143 + 11806‚Äã EN.WIKIPEDIA.ORG . These esoteric patterns show how unit fractions intersect with the theory of divisors and special integers. Finally, a word on computational complexity: finding an Egyptian fraction representation (without additional constraints) is easy via the greedy algorithm, but finding one that minimizes the number of terms or the largest denominator is much harder. No efficient algorithm is known to minimize the number of terms; the search space seems to grow quickly, and it‚Äôs suspected that these minimization problems might be NP-hard (though it remains unproven)‚Äã EN.WIKIPEDIA.ORG . The Egyptian fraction problem has many open questions: Are there efficient algorithms to find expansions with, say, the least maximum denominator? How few terms are needed in general to represent any ab (a conjecture by Erd≈ës posited O(log b) terms always suffice; tighter conjectures say maybe O(loglog b) terms are enough‚Äã EN.WIKIPEDIA.ORG )? Such problems remain active areas of research, bridging number theory and computer science. Conclusion The simple fractions 1K and (K-1)K serve as fundamental building blocks in number theory and its applications. From ancient times, they were the basis of representing all rational numbers as sums of unit fractions ‚Äì a practice that, while no longer used for practical arithmetic, has inspired deep theoretical questions. We‚Äôve seen that every rational number can be composed from unit fractions, often starting with a term like 1K or (K-1)K to approximate the target and then refining the remainder. These fractions show elegant patterns: Egyptian fraction identities, complementary repeating decimals, and modular relationships. They also lead to challenging Diophantine equations: finding integers xyzdots such that fracab = frac1x+frac1y+cdots is a classical problem with many unsolved cases (like the Erd≈ës‚ÄìStraus conjecture for 4n‚Äã EN.WIKIPEDIA.ORG ). On the other hand, much progress has been made ‚Äì for instance, every fraction with odd denominator has an expansion using odd unit fractions‚Äã EN.WIKIPEDIA.ORG , and every large enough integer can be partitioned to yield an Egyptian sum for 1‚Äã EN.WIKIPEDIA.ORG . In a way, exploring 1K and (K-1)K is exploring how the number 1 can be broken into harmonious parts. The ancient Egyptians might have seen it as practical arithmetic and fair division, while modern mathematicians see combinatorial structures and infinite possibilities. These tiny fractions connect the very concrete (sharing 5 pizzas among 8 people) to the very abstract (coloring integers or analyzing prime divisors). The fascination of unit fractions endures ‚Äì a testament to how even the simplest components of arithmetic hide endless patterns and puzzles in their reciprocals. Sources: Historical details from the Rhind Papyrus and Egyptian fraction usage‚Äã EN.WIKIPEDIA.ORG ‚Äã EN.WIKIPEDIA.ORG ‚Äã EN.WIKIPEDIA.ORG ; Fibonacci‚Äôs greedy algorithm and identities‚Äã EN.WIKIPEDIA.ORG ‚Äã R-KNOTT.SURREY.AC.UK ; examples of expansions‚Äã R-KNOTT.SURREY.AC.UK ‚Äã R-KNOTT.SURREY.AC.UK ; modern results on Egyptian fractions and conjectures‚Äã R-KNOTT.SURREY.AC.UK ‚Äã EN.WIKIPEDIA.ORG ‚Äã EN.WIKIPEDIA.ORG ‚Äã EN.WIKIPEDIA.ORG . Patterns in Modular Arithmetic and Repeating Decimals Unit fractions have a natural connection to modular arithmetic, especially when we consider their decimal (or other base) expansions. If K is coprime to 10, the decimal expansion of 1K will be repeating (non-terminating), and its repetend (the repeating block of digits) is intimately related to the multiplicative order of 10 modulo K. In fact, the length of the repeating cycle of 1K is the smallest positive integer d such that 10^d equiv 1 pmodK. For example, 17 = 0overline142857 has a repetend of length 6, and indeed 10^6 = 1000000 equiv 1 pmod7. The repeating digits 142857 are not random; they form what is known as a cyclic number. Multiplying 142857 by any number from 2 through 6 permutes its digits (e.g. 142857 times 2 = 285714), reflecting the fact that 27 37  67 produce cyclic permutations of the same repetend. In particular, frac67 = 0overline857142, which is exactly the ‚Äúcomplement‚Äù of 0overline142857 in the sense that 0overline142857 + 0overline857142 = 0overline999999 = 0999999ldots = 1. Generally, for a denominator K (coprime to the base), 1K and (K-1)K have repeating decimals that are complements of each other: digit by digit, they sum to 9 (in base 10). Another simple example: 13 = 0overline3 and 23 = 0overline6; indeed 3+6=9 in each repeating digit. Similarly, 111 = 0overline09 and 1011 = 0overline90. This pattern arises because (K-1)K = 1 - 1K, so its decimal expansion is the subtraction of 0overlinetext(repetend of 1K) from 1, which yields the 9‚Äôs complement repetend. In modular arithmetic terms, saying 10^d equiv 1 pmodK means K divides 10^d - 1, so 1K = fracA10^d - 1 for some integer A. Here 10^d-1 is a number like 99...9 (d digits of 9), and indeed A will be the integer formed by the repetend digits. For example, 17 = 142857999999 and 67 = 857142999999. This is a clear algebraic relation between a fraction and its repeating pattern. Beyond base-10 patterns, unit fractions also connect to general modular inverses. The number 1K (as a rational number) corresponds to the multiplicative inverse of K in the ring of integers modulo m, if gcd(Km)=1. For instance, 1K pmodp (for p prime not dividing K) is the unique number x such that Kx equiv 1 pmodp. This is essentially Fermat‚Äôs little theorem in action: one can show K^p-1 equiv 1 pmodp, hence K^p-2 equiv K^-1 pmodp, meaning x = K^p-2 is the residue corresponding to 1K. One interesting property here is that the sum of all such modular reciprocals in a prime field has a nice result: for a prime p2,  1","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 2","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 3","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"‚ãØ","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùëù ‚àí 1 ‚â° 0 ( m o d ùëù ) , 1+  2 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"3 1 ‚Äã  +‚ãØ+  p‚àí1 1 ‚Äã  ‚â°0(modp), when interpreted modulo p. This is because the set 1^-12^-1dots(p-1)^-1 is just a permutation of 12dotsp-1 modulo p. For example, mod 7: 1+12+13+14+15+16 equiv 1+4+5+2+3+6 = 21 equiv 0 pmod7. A far deeper result along these lines is Wolstenholme‚Äôs theorem (1862), which states that for any prime p3, the numerator of 1 + frac12 + cdots + frac1p-1 (when written in lowest terms) is divisible by p^2. This implies a congruence like 1 + frac12 + cdots + frac1p-1 equiv 0 pmodp^2 in a certain well-defined sense. Although not directly about 1K vs (K-1)K, Wolstenholme‚Äôs theorem underscores the special role of unit fractions summing up in modular arithmetic contexts. In summary, the forms 1K and (K-1)K show up in base-dependent patterns (like repeating decimals) and base-independent congruences (like properties of harmonic sums mod p). The complement pair 1K and (K-1)K often exhibit symmetry: one might call (K-1)K the ‚Äú9‚Äôs complement‚Äù of 1K in decimal, or in any base the analogous complement to the full reptend. Diophantine Equations and Egyptian Fraction Problems Expressions involving sums of unit fractions naturally lead to Diophantine equations. A classic example is the equation:  1 ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùë¶ = 1 ùëõ , x 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"y 1 ‚Äã  =  n 1 ‚Äã  , with xyn positive integers. Solving this is equivalent to finding an Egyptian fraction representation of 1n with two terms. Clearing denominators gives xy as a multiple of n:  1 ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùë¶ = 1 ùëõ ‚ÄÖ‚Ää ‚ü∫ ‚ÄÖ‚Ää ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"ùë¶ ùë• ùë¶ = 1 ùëõ ‚ÄÖ‚Ää ‚ü∫ ‚ÄÖ‚Ää ùë• ùë¶ = ùëõ ( ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"ùë¶ ) . x 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"y 1 ‚Äã  =  n 1 ‚Äã  ‚ü∫  xy x+y ‚Äã  =  n 1 ‚Äã  ‚ü∫xy=n(x+y). Rearrange to xy - nx - ny = 0 or (x-n)(y-n) = n^2. Thus solutions correspond to pairs of divisors of n^2. For each divisor d of n^2, one can set x-n = d and y-n = fracn^2d, yielding x = d+n and y = fracn^2d + n. This describes all solutions in positive integers. For example, with n=4: (x-4)(y-4)=16. The divisors of 16 give solutions like x-4=1 y-4=16 (so x=5 y=20) corresponding to 15+120=14; or x-4=2 y-4=8 (so x=6y=12) giving 16+112=14; or x-4=4y-4=4 (x=y=8) giving 18+18=14. That last solution uses a repeated unit fraction, which Egyptians would not allow, but mathematically it‚Äôs a valid solution of the equation. We see there are infinitely many representations of frac14 if we allowed repetition, but with the distinctness restriction we have finitely many (in this case two: 15+120 and 16+112) because (xy) and (yx) are considered the same representation for Egyptian fractions. This kind of analysis can be extended to equations with more terms, but it becomes much more complex. One famous problem in this vein is the Erd≈ës‚ÄìStraus conjecture (1948), which focuses on representations of frac4n as a sum of three unit fractions. The conjecture asserts that for every integer nge 2, there exist positive integers xyz such that:  4 ùëõ = 1 ùë•","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùë¶","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"1 ùëß . n 4 ‚Äã  =  x 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"y 1 ‚Äã","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"z 1 ‚Äã  . In other words, frac4n has an Egyptian fraction expansion of length 3 (not necessarily with distinct denominators, though one can often make them distinct). Despite extensive effort, this conjecture remains unproven in full generality ‚Äì it is one of the longest-standing open problems about Egyptian fractions. It has been verified by computer for very large n (all n  10^17, as well as ‚Äúalmost all‚Äù n beyond that range)‚Äã EN.WIKIPEDIA.ORG , but a general proof is unknown. The conjecture is interesting because frac4n is (n-4)n plus a bit more complexity; why the numerator 4? It appears that 4 is the smallest integer where the property of always having a 3-term expansion might be hard to guarantee ‚Äì for frac3n, it‚Äôs known to be always possible with at most 3 terms, as we‚Äôll discuss next. Erd≈ës and Straus allowing repeated denominators means they considered solutions to 4n = 1x+1y+1z in positive integers without the distinctness condition (one could have x=y for instance). However, any solution with a repeat can be transformed into a solution with distinct terms (usually with more terms) by a transformation akin to the one by Takenouchi (1921)‚Äã EN.WIKIPEDIA.ORG . Empirical evidence strongly suggests Erd≈ës‚ÄìStraus is true ‚Äì no counterexample has been found up to very large n‚Äã EN.WIKIPEDIA.ORG  ‚Äì but it exemplifies how a simple question about unit fractions leads to deep difficulties. What about frac3n or other numerators? If n is a multiple of 3, frac3n is itself a unit fraction (=1(n3)), so the interesting cases are when 3nmid n. In 2000, Timothy Hagedorn proved that if n is not divisible by 3 and is odd, then frac3n can always be written as a sum of three distinct odd unit fractions‚Äã R-KNOTT.SURREY.AC.UK . For example, frac35 = frac12 + frac15 + frac110 (here one denominator is even, 10, so not all odd in this representation; Hagedorn‚Äôs theorem would guarantee a representation like frac35 = frac13 + frac14 + frac160 which uses only odd denominators except the 4‚Ä¶ perhaps a better example: frac37 = frac13 + frac111 + frac1231 uses odd denominators 3,11,231). If n is even and not a multiple of 3, frac3n also appears always to have a 3-term expansion (often even a 2-term one, e.g. frac310 = frac14+frac120). In fact, it‚Äôs known that every frac3n has a three-term expansion (with the possible exception of some even n that are powers of 2, which trivially don‚Äôt since frac32^k reduces to frac32^k and needs at least 3 terms). The case for frac5n and others grows progressively harder; there is no known simple criterion like the Erd≈ës‚ÄìStraus conjecture for 5, but computations suggest frac5n often needs at most 4 terms. Research continues into these kinds of problems, and they blend techniques from number theory, algebra, and computational search. Another intriguing result in this domain was the Erd≈ës‚ÄìGraham conjecture (proposed in 1980 by Paul Erd≈ës and Ronald Graham), which was solved in 2003. This was not about a single fraction but about partitioning the integers. It stated that if the positive integers greater than 1 are arbitrarily partitioned into finitely many subsets, one of those subsets will contain an ‚ÄúEgyptian fraction‚Äù sum that equals 1‚Äã EN.WIKIPEDIA.ORG . In plain terms: no matter how you color the integers in a fixed number of colors, you can always find a monochromatic set of numbers d_1dotsd_k such that frac1d_1+cdots+frac1d_k=1. This was proved by Ernie Croot in 2003‚Äã EN.WIKIPEDIA.ORG , confirming a deep fact about unit fractions summing to 1. Notice the sum to 1 can be seen as a special case of the complement idea: summing to 1 means you‚Äôve perfectly expressed 1 (which is NN for any N) as an Egyptian fraction. Indeed, expressing 1 itself as an Egyptian fraction has a tie to number theory: a number N is perfect if 1 + frac12 + cdots + frac1N-1 = 1 when restricting the sum to divisors of N. For example, 6 is perfect because 6 = 1+2+3, which yields 1 = 12 + 13 + 16. 28 is perfect (divisors 1+2+4+7+14=28) giving 1 = 12+14+17+114+128. More generally, primary pseudoperfect numbers are those that allow an Egyptian fraction of 1 that includes the number itself in the denominators. An example is 1806, which has the property 1806 = 2 times 3 times 7 times 43 divides something and indeed 1 = 12 + 13 + 17 + 143 + 11806‚Äã EN.WIKIPEDIA.ORG . These esoteric patterns show how unit fractions intersect with the theory of divisors and special integers. Finally, a word on computational complexity: finding an Egyptian fraction representation (without additional constraints) is easy via the greedy algorithm, but finding one that minimizes the number of terms or the largest denominator is much harder. No efficient algorithm is known to minimize the number of terms; the search space seems to grow quickly, and it‚Äôs suspected that these minimization problems might be NP-hard (though it remains unproven)‚Äã EN.WIKIPEDIA.ORG . The Egyptian fraction problem has many open questions: Are there efficient algorithms to find expansions with, say, the least maximum denominator? How few terms are needed in general to represent any ab (a conjecture by Erd≈ës posited O(log b) terms always suffice; tighter conjectures say maybe O(loglog b) terms are enough‚Äã EN.WIKIPEDIA.ORG )? Such problems remain active areas of research, bridging number theory and computer science. Conclusion The simple fractions 1K and (K-1)K serve as fundamental building blocks in number theory and its applications. From ancient times, they were the basis of representing all rational numbers as sums of unit fractions ‚Äì a practice that, while no longer used for practical arithmetic, has inspired deep theoretical questions. We‚Äôve seen that every rational number can be composed from unit fractions, often starting with a term like 1K or (K-1)K to approximate the target and then refining the remainder. These fractions show elegant patterns: Egyptian fraction identities, complementary repeating decimals, and modular relationships. They also lead to challenging Diophantine equations: finding integers xyzdots such that fracab = frac1x+frac1y+cdots is a classical problem with many unsolved cases (like the Erd≈ës‚ÄìStraus conjecture for 4n‚Äã EN.WIKIPEDIA.ORG ). On the other hand, much progress has been made ‚Äì for instance, every fraction with odd denominator has an expansion using odd unit fractions‚Äã EN.WIKIPEDIA.ORG , and every large enough integer can be partitioned to yield an Egyptian sum for 1‚Äã EN.WIKIPEDIA.ORG . In a way, exploring 1K and (K-1)K is exploring how the number 1 can be broken into harmonious parts. The ancient Egyptians might have seen it as practical arithmetic and fair division, while modern mathematicians see combinatorial structures and infinite possibilities. These tiny fractions connect the very concrete (sharing 5 pizzas among 8 people) to the very abstract (coloring integers or analyzing prime divisors). The fascination of unit fractions endures ‚Äì a testament to how even the simplest components of arithmetic hide endless patterns and puzzles in their reciprocals.","category":"page"},{"location":"unitcomplementQ/","page":"-","title":"-","text":"","category":"page"},{"location":"glossary/","page":"-","title":"-","text":"unit fraction     A fraction with a numerator of 1. For example, 1/2, 1/3, and 1/4 are unit fractions.     [ \"The Rational Number n/p  as a sum of two unit fractions\"       Konstantine Zelator, 2012-Feb-29. https://arxiv.org/pdf/1203.0018     ]      ]","category":"page"},{"location":"glossary/","page":"-","title":"-","text":"unit fraction and complementary unit fraction     A unit fraction is a positive rational number 1/K with numerator 1 and denominator integer K>0.     The complement (complementary unit fraction) is 1 - 1/K == (K - 1) / K.","category":"page"},{"location":"glossary/","page":"-","title":"-","text":"1/K + (K - 1)/K == (1 + (K - 1)) / K == (K + 1 - 1) / K == K/K == 1     [ \"The Rational Number n/p  as a sum of two unit fractions\"       Konstantine Zelator, 2012-Feb-29. https://arxiv.org/pdf/1203.0018","category":"page"},{"location":"glossary/","page":"-","title":"-","text":"0/K, 1/K, 2/K, 3/K, ... (K-2)/K, (K-1)/K, K/K      ^ unit fraction              ^ complementary unit fraction      ^ Qunit fraction             ^ Qcomplement","category":"page"},{"location":"glossary/","page":"-","title":"-","text":"0/1 < Qunit < ... <  Qcomplement  < 1/1","category":"page"},{"location":"glossary/","page":"-","title":"-","text":"subnormalmin(nFracBits(T)) == Qunit(nFracBits(T)) subnormalmax(nFracBits(T)) == Qcomplement(nFracBits(T))","category":"page"},{"location":"glossary/","page":"-","title":"-","text":"","category":"page"},{"location":"acknowledgements/","page":"Acknowledgements","title":"Acknowledgements","text":"The deep, careful, expert work of P3109 SA is seen everywhere in this workproduct.","category":"page"},{"location":"acknowledgements/","page":"Acknowledgements","title":"Acknowledgements","text":"","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"","category":"page"},{"location":"mathfunctions/","page":"Mathematical Functions","title":"Mathematical Functions","text":"The comparisons <, <=, ==, !=, >=. >, which resolve as Boolean values. ","category":"page"},{"location":"mathfunctions/","page":"Mathematical Functions","title":"Mathematical Functions","text":"The basic unary arithmetic functions \n+x. -x. abs, negate, reciprocal\nThe basic binary arithmetic functions\n+, -, *, /\nEssential numerical selector functions\nminimum, maximum\nminmumMagnitude, maximumMagnitude\nTheir Number-only variants that ignore NaNs,\nminimumNumber, maximumNumber\nminimumMagnitudeNumber, maximumMagnitudeNumber","category":"page"},{"location":"mathfunctions/","page":"Mathematical Functions","title":"Mathematical Functions","text":"","category":"page"},{"location":"overview/#Floating-Point-Types-Consistent-with-P3109","page":"Overview","title":"Floating-Point Types Consistent with P3109","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The IEEE SA P3109 Working Group  is drafting a standard for floating-point formats used in machine learning.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Here are floating-point types consistent with the current draft of The Interim Report. .</br> However, until the IEEE issues the Standard, there may substantive changes.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"specifics/","page":"Type Specifics","title":"Type Specifics","text":"These features are obtainable for all of our floating-point formats.","category":"page"},{"location":"specifics/","page":"Type Specifics","title":"Type Specifics","text":"These predicates: is_signed, is_unsigned, is_finite, is_extended. ","category":"page"},{"location":"specifics/","page":"Type Specifics","title":"Type Specifics","text":"These characterizing counts:","category":"page"},{"location":"specifics/","page":"Type Specifics","title":"Type Specifics","text":"bitwidth, precision,\nnValues, nNumericValues, nFiniteValues, nNormalValues, nSubnormalValues,\nnMagnitudes, nFiniteMagnitudes nNormalMagnitudes, nSubnormalMagnitudes,\n\nnBits, nSignBits, nExpBits, nSigBits, nFracBits","category":"page"},{"location":"specifics/","page":"Type Specifics","title":"Type Specifics","text":"These extremal values:","category":"page"},{"location":"specifics/","page":"Type Specifics","title":"Type Specifics","text":"floatmin, floatmax, exponent_min, exponent_max\nsubnormal_min, subnormal_max, normal_min, normal_max","category":"page"},{"location":"specifics/","page":"Type Specifics","title":"Type Specifics","text":"","category":"page"},{"location":"abstractions/#Abstractions","page":"Computing over Type abstractions","title":"Abstractions","text":"","category":"section"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"graph TD\n    A[AbstractAIFloat]\n    A--> S[AbsSignedFloat]\n    A--> U[AbsUnsignedFloat]\n    S--> SF[AbsSignedFiniteFloat]\n    S--> SE[AbsSignedExtendedFloat]\n    U--> UF[AbsUnsignedFiniteFloat]\n    U--> UE[AbsUnsignedExtendedFloat]","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"graph LR\n    A[AbstractAIFloat]\n    A--> S[Signed]\n    A--> U[Unsigned]\n    S--> SF[Finite ‚äï NaN]\n    S--> SE[Finite ‚äï Inf ‚äï NaN]\n    U--> UF[Finite ‚äï NaN]\n    U--> UE[Finite ‚äï Inf ‚äï NaN]","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"","category":"page"},{"location":"abstractions/#Computing-over-these-abstractions","page":"Computing over Type abstractions","title":"Computing over these abstractions","text":"","category":"section"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"Every predicate, count, and extremal value available in [Type Specifics] is defined over these abstract types. We do not require instantiations to know characterizations.  The way that we stage our abstract parameterizations allows the freedom to use declarations like this:","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"abstract type AbstractAIFloat{Bits, Precision} <: AbstractFloat end\n#                        B is Bits, P is Precision == SigBits\nbitsize(::Type{<:AbstractAIFloat{B,P}}) where {B,P} = B\nsigbits(::Type{<:AbstractAIFloat{B,P}}) where {B,P} = P\n# the fractional bits (or trailing significand bits) are explicitly stored\nfracbits(::Type{<:AbstractAIFloat{B,P}}) where {B,P} = P - 1\n\nsignbits(T::Type{<:AbstractAIFloat{Bits,Precision}}) where {Bits,Precision} =\n     0 + is_signed(T)\n\nexpbits(T::Type{<:AbstractAIFloat{Bits,Precision}}) where {Bits,Precision} =\n   Bits - Precision + is_unsigned(T)\n\nnValues(T::Type{<:AbstractAIFloat}) = 2^nBits(T)\nnNumericValues(T::Type{<:AbstractAIFloat}) = nValues(T) - 1 # remove NaN\nnFiniteValues(T::Type{<:AbstractAIFloat}) = nNumericValues(T) - nInfs(T) # remove Infs\n\nnInfs(T::Type{<:AbstractAIFloat}) = is_extended(T) * (is_signed(T) + is_extended(T))","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"and then","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"for F in (:bitsize, :sigbits, :fracbits, :expbits, :signbits,\n          :nValues, :nNumericValues, :nFiniteValues, :nInfs)\n    @eval $(F)(x::AbstractAIFloat) = $(F)(typeof(x))\nend","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"====","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"In essence, this code provides a framework for creating custom floating-point numeric types in Julia by defining essential properties and methods that describe their bit structure. It allows the user to query information about bits, significance, and the count of representable values including handling special cases like NaN and infinity. This abstraction enables more straightforward implementation and manipulation of different floating-point representations in a systematic way.","category":"page"},{"location":"abstractions/","page":"Computing over Type abstractions","title":"Computing over Type abstractions","text":"","category":"page"},{"location":"#AIFloats","page":"Home","title":"AIFloats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The IEEE SA P3109 Working Group  is drafting a standard for floating-point formats used in machine learning.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are defining a family of data formats and providing binary arithmetic optimized for machine learning and related domains. The intent is to provide a consistent and flexible arithmetic framework optimized for Machine Learning Systems that may be implemented in hardware or in software or both combined. Having a shared standard improves interoperability.  The formats are designed to be efficient, consistent and highly performant.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is the source code for this package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
