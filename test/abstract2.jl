# generated by Claude Sonnet 4 2025-06-08T09:49Z 
# using Julia and Julia Best Practices write test functions for "abstract2.jl"

using Test

# Define concrete test types for testing
struct TestSignedFiniteFloat8_4 <: AbsSignedFiniteFloat{8, 4} end
struct TestSignedExtendedFloat8_4 <: AbsSignedExtendedFloat{8, 4} end
struct TestUnsignedFiniteFloat8_4 <: AbsUnsignedFiniteFloat{8, 4} end
struct TestUnsignedExtendedFloat8_4 <: AbsUnsignedExtendedFloat{8, 4} end

struct TestSignedFiniteFloat16_8 <: AbsSignedFiniteFloat{16, 8} end
struct TestUnsignedFiniteFloat16_8 <: AbsUnsignedFiniteFloat{16, 8} end

@testset "AbstractAIFloat Tests" begin
    
    @testset "Type Hierarchy and Predicates" begin
        # Test signed/unsigned predicates
        @test is_signed(TestSignedFiniteFloat8_4)
        @test !is_signed(TestUnsignedFiniteFloat8_4)
        @test !is_unsigned(TestSignedFiniteFloat8_4)
        @test is_unsigned(TestUnsignedFiniteFloat8_4)
        
        # Test finite/extended predicates
        @test is_finite(TestSignedFiniteFloat8_4)
        @test is_finite(TestUnsignedFiniteFloat8_4)
        @test !is_finite(TestSignedExtendedFloat8_4)
        @test !is_finite(TestUnsignedExtendedFloat8_4)
        
        @test !is_extended(TestSignedFiniteFloat8_4)
        @test !is_extended(TestUnsignedFiniteFloat8_4)
        @test is_extended(TestSignedExtendedFloat8_4)
        @test is_extended(TestUnsignedExtendedFloat8_4)
        
        # Test isa_ predicates for abstract types
        @test isa_signed(TestSignedFiniteFloat8_4)
        @test !isa_signed(TestUnsignedFiniteFloat8_4)
        @test !isa_unsigned(TestSignedFiniteFloat8_4)
        @test isa_unsigned(TestUnsignedFiniteFloat8_4)
        
        @test isa_finite(TestSignedFiniteFloat8_4)
        @test isa_finite(TestUnsignedFiniteFloat8_4)
        @test !isa_finite(TestSignedExtendedFloat8_4)
        @test !isa_finite(TestUnsignedExtendedFloat8_4)
        
        @test !isa_extended(TestSignedFiniteFloat8_4)
        @test !isa_extended(TestUnsignedFiniteFloat8_4)
        @test isa_extended(TestSignedExtendedFloat8_4)
        @test isa_extended(TestUnsignedExtendedFloat8_4)
    end
    
    @testset "Special Value Counts" begin
        # Test NaN and Zero counts (should be 1 for all types)
        for T in [TestSignedFiniteFloat8_4, TestUnsignedFiniteFloat8_4, 
                  TestSignedExtendedFloat8_4, TestUnsignedExtendedFloat8_4]
            @test nNaNs(T) == 1
            @test nZeros(T) == 1
        end
        
        # Test infinity counts
        @test nInfs(TestSignedFiniteFloat8_4) == 0
        @test nInfs(TestUnsignedFiniteFloat8_4) == 0
        @test nInfs(TestSignedExtendedFloat8_4) == 2
        @test nInfs(TestUnsignedExtendedFloat8_4) == 1
        
        # Test positive/negative infinity counts
        @test nPosInfs(TestSignedFiniteFloat8_4) == 0
        @test nPosInfs(TestUnsignedFiniteFloat8_4) == 0
        @test nPosInfs(TestSignedExtendedFloat8_4) == 1
        @test nPosInfs(TestUnsignedExtendedFloat8_4) == 1
        
        @test nNegInfs(TestSignedFiniteFloat8_4) == 0
        @test nNegInfs(TestUnsignedFiniteFloat8_4) == 0
        @test nNegInfs(TestSignedExtendedFloat8_4) == 1
        @test nNegInfs(TestUnsignedExtendedFloat8_4) == 0
    end
    
    @testset "Basic Bit Calculations" begin
        # Test for 8-bit, 4 sig bits type
        @test nBits(TestSignedFiniteFloat8_4) == 8
        @test nSigBits(TestSignedFiniteFloat8_4) == 4
        @test nFracBits(TestSignedFiniteFloat8_4) == 3
        @test Base.precision(TestSignedFiniteFloat8_4) == 4
        
        # Test for 16-bit, 8 sig bits type
        @test nBits(TestSignedFiniteFloat16_8) == 16
        @test nSigBits(TestSignedFiniteFloat16_8) == 8
        @test nFracBits(TestSignedFiniteFloat16_8) == 7
        @test Base.precision(TestSignedFiniteFloat16_8) == 8
        
        # Test total values
        @test nValues(TestSignedFiniteFloat8_4) == 256  # 2^8
        @test nValues(TestUnsignedFiniteFloat8_4) == 256  # 2^8
        @test nNumericValues(TestSignedFiniteFloat8_4) == 255  # 2^8 - 1
        @test nNonzeroNumericValues(TestSignedFiniteFloat8_4) == 254  # 2^8 - 2
    end
    
    @testset "Exponent Calculations" begin
        # Test exponent bits
        @test nExpBits(TestSignedFiniteFloat8_4) == 4  # 8 - 4
        @test nExpBits(TestUnsignedFiniteFloat8_4) == 5  # 8 - 4 + 1
        
        # Test exponent values
        @test nExpValues(TestSignedFiniteFloat8_4) == 16  # 2^4
        @test nExpValues(TestUnsignedFiniteFloat8_4) == 32  # 2^5
        @test nNonzeroExpValues(TestSignedFiniteFloat8_4) == 15
        @test nNonzeroExpValues(TestUnsignedFiniteFloat8_4) == 31
        
        # Test exponent bias
        @test expBias(TestSignedFiniteFloat8_4) == 8   # 2^(8-4-1) = 2^3
        @test expBias(TestUnsignedFiniteFloat8_4) == 16  # 2^(8-4) = 2^4
        
        # Test unbiased exponent ranges
        @test expUnbiasedMax(TestSignedFiniteFloat8_4) == 7  # (15 >> 1)
        @test expUnbiasedMin(TestSignedFiniteFloat8_4) == -7
        
        # Test exponent value functions
        @test expMaxValue(TestSignedFiniteFloat8_4) ≈ 2.0^7
        @test expMinValue(TestSignedFiniteFloat8_4) ≈ 2.0^(-7)
    end
    
    @testset "Magnitude Calculations" begin
        # Test magnitude counts
        @test nMagnitudes(TestSignedFiniteFloat8_4) == 128  # 256 >> 1
        @test nMagnitudes(TestUnsignedFiniteFloat8_4) == 255  # 256 - 1
        @test nNonzeroMagnitudes(TestSignedFiniteFloat8_4) == 127
        @test nNonzeroMagnitudes(TestUnsignedFiniteFloat8_4) == 254
        
        # Test significand magnitudes
        @test nSigMagnitudes(TestSignedFiniteFloat8_4) == 16  # 2^4
        @test nNonzeroSigMagnitudes(TestSignedFiniteFloat8_4) == 15
        @test nFracMagnitudes(TestSignedFiniteFloat8_4) == 8  # 2^3
        @test nNonzeroFracMagnitudes(TestSignedFiniteFloat8_4) == 7
    end
    
    @testset "Value Classification Counts" begin
        # Test finite value counts
        finite_signed = nFiniteValues(TestSignedFiniteFloat8_4)
        finite_unsigned = nFiniteValues(TestUnsignedFiniteFloat8_4)
        finite_signed_ext = nFiniteValues(TestSignedExtendedFloat8_4)
        finite_unsigned_ext = nFiniteValues(TestUnsignedExtendedFloat8_4)
        
        @test finite_signed == 255  # nNumericValues - nInfs = 255 - 0
        @test finite_unsigned == 255
        @test finite_signed_ext == 253  # 255 - 2
        @test finite_unsigned_ext == 254  # 255 - 1
        
        # Test positive/negative value counts for signed types
        @test nNonnegValues(TestSignedFiniteFloat8_4) == 128
        @test nPositiveValues(TestSignedFiniteFloat8_4) == 127
        @test nNegativeValues(TestSignedFiniteFloat8_4) == 127  # 255 - 128
        
        # Test finite positive/negative counts
        @test nFinitePositiveValues(TestSignedFiniteFloat8_4) == 127
        @test nFiniteNegativeValues(TestSignedFiniteFloat8_4) == 127
        @test nFiniteNonnegValues(TestSignedFiniteFloat8_4) == 128
    end
    
    @testset "Normal and Subnormal Counts" begin
        # Test prenormal/subnormal magnitudes
        @test nPrenormalMagnitudes(TestSignedFiniteFloat8_4) == 8  # 2^(4-1)
        @test nSubnormalMagnitudes(TestSignedFiniteFloat8_4) == 7   # 8 - 1
        
        # Test prenormal values
        @test nPrenormalValues(TestSignedFiniteFloat8_4) == 15  # 2*8 - 1
        @test nPrenormalValues(TestUnsignedFiniteFloat8_4) == 8   # just 8
        
        # Test subnormal values
        @test nSubnormalValues(TestSignedFiniteFloat8_4) == 14  # 15 - 1
        
        # Test normal counts
        normal_mags_signed = nNormalMagnitudes(TestSignedFiniteFloat8_4)
        normal_vals_signed = nNormalValues(TestSignedFiniteFloat8_4)
        
        @test normal_mags_signed >= 0
        @test normal_vals_signed >= 0
        
        # Extended normal counts
        ext_normal_mags = nExtendedNormalMagnitudes(TestSignedExtendedFloat8_4)
        ext_normal_vals = nExtendedNormalValues(TestSignedExtendedFloat8_4)
        
        @test ext_normal_mags >= normal_mags_signed
        @test ext_normal_vals >= 0
    end
    
    @testset "Instance Method Dispatch" begin
        # Create instances (these are just type tags, no actual data)
        signed_finite = TestSignedFiniteFloat8_4()
        unsigned_finite = TestUnsignedFiniteFloat8_4()
        signed_extended = TestSignedExtendedFloat8_4()
        
        # Test that instance methods work the same as type methods
        @test nBits(signed_finite) == nBits(TestSignedFiniteFloat8_4)
        @test is_signed(signed_finite) == is_signed(TestSignedFiniteFloat8_4)
        @test is_finite(signed_finite) == is_finite(TestSignedFiniteFloat8_4)
        @test nInfs(signed_extended) == nInfs(TestSignedExtendedFloat8_4)
        @test Base.precision(unsigned_finite) == Base.precision(TestUnsignedFiniteFloat8_4)
    end
    
    @testset "Magnitude and Value Sequence Functions" begin
        # Test prenormal magnitude steps
        prenormal_steps = prenormal_magnitude_steps(TestSignedFiniteFloat8_4)
        @test length(prenormal_steps) == nPrenormalMagnitudes(TestSignedFiniteFloat8_4)
        @test prenormal_steps[1] == 0.0
        @test prenormal_steps[end] < 1.0
        
        # Test normal magnitude steps
        normal_steps = normal_magnitude_steps(TestSignedFiniteFloat8_4)
        @test length(normal_steps) == nPrenormalMagnitudes(TestSignedFiniteFloat8_4)
        @test all(x -> x >= 1.0 && x < 2.0, normal_steps)
        
        # Test foundation exponents
        exp_min, exp_max = foundation_extremal_exps(TestSignedFiniteFloat8_4)
        @test exp_min <= exp_max
        @test exp_min < 0
        @test exp_max > 0
        
        foundation_exp_range = foundation_exps(TestSignedFiniteFloat8_4)
        @test first(foundation_exp_range) == exp_min
        @test last(foundation_exp_range) == exp_max
        
        # Test foundation magnitudes
        magnitudes = foundation_magnitudes(TestSignedFiniteFloat8_4)
        @test length(magnitudes) > 0
        @test all(x -> x >= 0.0, magnitudes)
        
        # Test value sequences for different types
        seq_signed_finite = value_sequence(TestSignedFiniteFloat8_4)
        seq_unsigned_finite = value_sequence(TestUnsignedFiniteFloat8_4)
        seq_signed_extended = value_sequence(TestSignedExtendedFloat8_4)
        seq_unsigned_extended = value_sequence(TestUnsignedExtendedFloat8_4)
        
        # All sequences should have appropriate lengths
        @test length(seq_signed_finite) > 0
        @test length(seq_unsigned_finite) > 0
        @test length(seq_signed_extended) > 0
        @test length(seq_unsigned_extended) > 0
        
        # Check that NaN is present in all sequences
        @test any(isnan, seq_signed_finite)
        @test any(isnan, seq_unsigned_finite)
        @test any(isnan, seq_signed_extended)
        @test any(isnan, seq_unsigned_extended)
        
        # Check that Inf is present in extended sequences
        @test any(isinf, seq_signed_extended)
        @test any(isinf, seq_unsigned_extended)
        
        # Check that finite sequences don't have Inf
        finite_vals_signed = filter(!isnan, seq_signed_finite)
        finite_vals_unsigned = filter(!isnan, seq_unsigned_finite)
        @test !any(isinf, finite_vals_signed)
        @test !any(isinf, finite_vals_unsigned)
    end
    
    @testset "Mathematical Properties and Consistency" begin
        # Test consistency between related functions
        T = TestSignedFiniteFloat8_4
        
        @test nValues(T) == nNumericValues(T) + 1
        @test nNumericValues(T) == nNonzeroNumericValues(T) + 1
        @test nSigMagnitudes(T) == nNonzeroSigMagnitudes(T) + 1
        @test nFracMagnitudes(T) == nNonzeroFracMagnitudes(T) + 1
        @test nExpValues(T) == nNonzeroExpValues(T) + 1
        
        # Test that exponent bias makes sense
        @test expBias(T) > 0
        @test expUnbiasedMax(T) > 0
        @test expUnbiasedMin(T) < 0
        @test expUnbiasedMax(T) == -expUnbiasedMin(T)
        
        # Test that magnitude counts are consistent
        @test nMagnitudes(T) == nNonzeroMagnitudes(T) + 1
        @test nFiniteValues(T) <= nNumericValues(T)
        @test nFiniteValues(T) == nNonzeroFiniteValues(T) + 1
        
        # For signed types, positive + negative + zero should equal total
        if is_signed(T)
            @test nPositiveValues(T) + nNegativeValues(T) + 1 == nNumericValues(T)
        end
    end
    
    @testset "Edge Cases and Error Conditions" begin
        # Test that all functions return non-negative integers where expected
        T = TestSignedFiniteFloat8_4
        
        for f in [nBits, nSigBits, nFracBits, nValues, nNumericValues, nNonzeroNumericValues, nMagnitudes, nNonzeroMagnitudes]
            result = f(T)
            @test result isa Integer
            @test result >= 0
        end
        
        # Test that precision function works with Base
        @test Base.precision(T) isa Integer
        @test Base.precision(T) > 0
        
        # Test boolean predicates return Bool
        for f in [is_signed, is_unsigned, is_finite, is_extended,
                  isa_signed, isa_unsigned, isa_finite, isa_extended]
            @test f(T) isa Bool
        end
    end
    
    @testset "Cross-Type Comparisons" begin
        # Compare signed vs unsigned types with same bit configuration
        T_signed = TestSignedFiniteFloat8_4
        T_unsigned = TestUnsignedFiniteFloat8_4
        
        @test nBits(T_signed) == nBits(T_unsigned)
        @test nSigBits(T_signed) == nSigBits(T_unsigned)
        @test nValues(T_signed) == nValues(T_unsigned)
        
        # But exponent bits should differ
        @test nExpBits(T_signed) != nExpBits(T_unsigned)
        @test expBias(T_signed) != expBias(T_unsigned)
        
        # Compare finite vs extended types
        T_finite = TestSignedFiniteFloat8_4
        T_extended = TestSignedExtendedFloat8_4
        
        @test nInfs(T_finite) < nInfs(T_extended)
        @test nFiniteValues(T_finite) > nFiniteValues(T_extended)
    end
end

# Additional helper function tests
@testset "Helper Functions" begin
    @testset "two_pow function" begin
        @test two_pow(0) ≈ 1.0f0
        @test two_pow(1) ≈ 2.0f0
        @test two_pow(-1) ≈ 0.5f0
        @test two_pow(3) ≈ 8.0f0
    end
    
    @testset "Complex function chains" begin
        T = TestSignedFiniteFloat8_4
        
        # Test that exp_unbiased_magnitude_strides works
        strides = exp_unbiased_magnitude_strides(T)
        @test length(strides) > 0
        @test all(x -> x isa Integer, strides)
        
        # Test pow2_foundation_exps with proper result vector
        result_vec = Float32[]
        pow2_result = pow2_foundation_exps(T, result_vec)
        @test length(pow2_result) > 0
        @test all(x -> x > 0, pow2_result)
    end
end

