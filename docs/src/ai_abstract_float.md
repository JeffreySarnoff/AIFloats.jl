(generated by Claude Sonnet 4 2025-06-08T10:17Z)
# AbstractAIFloat Documentation

A comprehensive floating-point type system for AI applications with configurable precision and special value handling.

## Table of Contents

- [Overview](#overview)
- [Type Hierarchy](#type-hierarchy)
- [Quick Start](#quick-start)
- [API Reference](#api-reference)
- [Examples](#examples)
- [Advanced Usage](#advanced-usage)
- [Performance Considerations](#performance-considerations)

## Overview

The `AbstractAIFloat` system provides a flexible framework for defining custom floating-point types optimized for AI and machine learning applications. It supports:

- **Configurable bit widths** and significand precision
- **Signed and unsigned** variants
- **Finite and extended** (with infinity) representations
- **Comprehensive introspection** functions for type properties
- **Value sequence generation** for systematic exploration of the number space

### Key Features

- 🎯 **Precision Control**: Customize total bits and significand bits independently
- 🔄 **Sign Variants**: Support both signed and unsigned number representations  
- ♾️ **Infinity Handling**: Choose finite-only or extended (with ±∞) representations
- 📊 **Rich Metadata**: Extensive functions to query type properties and counts
- 🎲 **Value Generation**: Built-in functions to generate complete value sequences

## Type Hierarchy

```julia
AbstractAIFloat{Bits, SigBits, IsSigned} <: AbstractFloat
├── AbstractSigned{Bits, SigBits}   # IsSigned = true
│   ├── AkoSignedFinite{Bits, SigBits}     # No infinities
│   └── AkoSignedExtended{Bits, SigBits}   # With ±∞
└── AbstractUnsigned{Bits, SigBits} # IsSigned = false  
    ├── AkoUnsignedFinite{Bits, SigBits}   # No infinities
    └── AkoUnsignedExtended{Bits, SigBits} # With +∞ only
```

### Type Parameters

- **`Bits`**: Total number of bits in the representation (e.g., 8, 16, 32)
- **`SigBits`**: Number of significand bits including implicit leading bit
- **`IsSigned`**: Boolean indicating if the type supports negative values

## Quick Start

```julia
# Define concrete types by subtyping the abstracts
struct MyFloat8_4 <: AkoSignedFinite{8, 4} end
struct MyUFloat8_4 <: AkoUnsignedFinite{8, 4} end

# Query basic properties
nbits(MyFloat8_4)     # 8
nbits_sig(MyFloat8_4)  # 4  
nbits_frac(MyFloat8_4) # 3
is_signed(MyFloat8_4) # true
is_finite(MyFloat8_4) # true

# Count different value types
nvalues(MyFloat8_4)         # 256 (total possible values)
nvalues_finite(MyFloat8_4)   # 255 (excluding NaN)
nvalues_positive(MyFloat8_4) # 127 (positive finite values)

# Generate value sequences
values = value_seq(MyFloat8_4)  # Complete sequence of representable values
```

## API Reference

### Type Predicates

Functions to determine type characteristics:

#### `is_signed(T)` / `is_unsigned(T)`
```julia
is_signed(::Type{T}) where {T<:AbstractAIFloat} → Bool
is_unsigned(::Type{T}) where {T<:AbstractAIFloat} → Bool
```
Test whether a type supports negative values.

**Examples:**
```julia
is_signed(AkoSignedFinite{8,4})   # true
is_unsigned(AkoUnsignedFinite{8,4}) # true
```

#### `is_finite(T)` / `is_extended(T)`
```julia
is_finite(::Type{T}) where {T<:AbstractAIFloat} → Bool  
is_extended(::Type{T}) where {T<:AbstractAIFloat} → Bool
```
Test whether a type includes infinity values.

**Examples:**
```julia
is_finite(AkoSignedFinite{8,4})   # true
is_extended(AkoSignedExtended{8,4}) # true
```

#### Abstract Type Predicates

For use with abstract supertypes:

```julia
isa_signed(@nospecialize(T::Type{<:AbstractSigned})) → Bool
isa_unsigned(@nospecialize(T::Type{<:AbstractUnsigned})) → Bool  
isa_finite(@nospecialize(T::Type{<:AkoSignedFinite})) → Bool
isa_extended(@nospecialize(T::Type{<:AkoSignedExtended})) → Bool
```

### Basic Properties

#### Bit Layout Functions
```julia
nbits(T) → Int          # Total bits in representation
nbits_sig(T) → Int       # Significand bits (including implicit bit)
nbits_frac(T) → Int      # Fractional bits (nbits_sig - 1)
nbits_exp(T) → Int       # Exponent bits
```

**Note:** Unsigned types get an extra exponent bit since no sign bit is needed.

#### Value Counts
```julia
nvalues(T) → Int                # Total representable values (2^nbits)
nvalues_numeric(T) → Int         # Non-NaN values  
nvalues_numeric_nonzero(T) → Int  # Non-NaN, non-zero values
```

### Special Value Counts

#### NaN, Zero, and Infinity Counts
```julia
nNaNs(T) → Int      # Always 1
nZeros(T) → Int     # Always 1  
nInfs(T) → Int      # 0 for finite, 1 for unsigned extended, 2 for signed extended
nPosInfs(T) → Int   # Positive infinities
nNegInfs(T) → Int   # Negative infinities (0 for unsigned)
```

### Magnitude and Sign Counts

#### Magnitude Functions
```julia
nmagnitudes(T) → Int           # Total magnitude values
nmagnitudes_nonzero(T) → Int    # Non-zero magnitude values
nmagnitudes_finite(T) → Int     # Finite magnitude values
```

#### Sign-Specific Counts
```julia
nvalues_nonneg(T) → Int         # Non-negative values (≥ 0)
nvalues_positive(T) → Int       # Positive values (> 0)  
nvalues_negative(T) → Int       # Negative values (< 0)
nvalues_finite_positive(T) → Int # Finite positive values
nvalues_finite_negative(T) → Int # Finite negative values
```

### Normal and Subnormal Counts

#### Subnormal (Denormalized) Values
```julia
nmagnitudes_prenormal(T) → Int  # Magnitudes in subnormal range (including zero)
nmagnitudes_subnormal(T) → Int  # Non-zero subnormal magnitudes
nvalues_prenormal(T) → Int      # Subnormal values (including zero)
nvalues_subnormal(T) → Int      # Non-zero subnormal values
```

#### Normal Values  
```julia
nmagnitudes_normal(T) → Int        # Normal magnitude values
nvalues_normal(T) → Int            # Normal values
nmagnitudes_normal_extended(T) → Int # Normal + infinity magnitudes
nvalues_normal_extended(T) → Int    # Normal + infinity values
```

### Exponent System

#### Exponent Properties
```julia
exp_bias(T) → Int              # Exponent bias
exp_unbiased_max(T) → Int       # Maximum unbiased exponent
exp_unbiased_min(T) → Int       # Minimum unbiased exponent  
exp_unbiased_seq(T) → Vector # All unbiased exponent values
exp_value_max(T) → Float64      # 2^exp_unbiased_max
exp_value_min(T) → Float64      # 2^exp_unbiased_min
```

#### Exponent Counts
```julia
nvalues_exp(T) → Int           # Total exponent values (2^nbits_exp)
nvalues_exp_nonzero(T) → Int    # Non-zero exponent values
```

### Significand Properties

```julia
nmagnitudes_sig(T) → Int       # Significand magnitude values (2^nbits_sig)
nmagnitudes_sig_nonzero(T) → Int # Non-zero significand magnitudes
nmagnitudes_frac(T) → Int      # Fractional part values (2^nbits_frac)  
nmagnitudes_frac_nonzero(T) → Int # Non-zero fractional parts
```

### Value Generation Functions

#### Magnitude Step Functions
```julia
prenormal_magnitude_steps(T) → Vector{Float64}
normal_magnitude_steps(T) → Vector{Float64}
```
Generate normalized magnitude steps for subnormal and normal ranges.

#### Foundation Functions
```julia
foundation_extremal_exps(T) → Tuple{Int, Int}    # (min_exp, max_exp)
foundation_exps(T) → UnitRange{Int}              # Range of foundation exponents
magnitude_foundation_seq(T) → Vector{Float64}       # Base magnitude values
```

#### Complete Value Sequences
```julia
value_seq(T) → Vector{Float64}
```
Generate the complete sequence of representable values for the type, including special values (NaN, ±∞) in appropriate positions.

**Behavior by type:**
- **Finite types**: Last value is NaN
- **Extended types**: Penultimate value is +∞ (or +∞/-∞ for signed), last is NaN
- **Signed types**: Negative values appended, with NaN replacing -0

### Utility Functions

```julia
two_pow(x::Integer) → Float32  # Efficient 2^x computation
normal_exp_stride(T) → Int     # Stride between exponent groups
exp_unbiased_magnitude_strides(T) → Vector{Int} # Exponent strides for magnitudes
pow2_foundation_exps(T, res) → Vector{Float32}  # 2^exponent values
```

## Examples

### Example 1: 8-bit Signed Finite Float with 4 Significand Bits

```julia
struct Float8_4 <: AkoSignedFinite{8, 4} end

# Basic properties
@show nbits(Float8_4)          # 8
@show nbits_sig(Float8_4)       # 4  
@show nbits_exp(Float8_4)       # 4 (8 - 4 = 4)
@show exp_bias(Float8_4)        # 8 (2^(8-4-1) = 2^3)

# Value counts
@show nvalues(Float8_4)        # 256 (2^8)
@show nvalues_finite(Float8_4)  # 255 (no infinities)
@show nvalues_positive(Float8_4) # 127 (half minus zero)
@show nvalues_negative(Float8_4) # 127

# Subnormal analysis  
@show nmagnitudes_prenormal(Float8_4)  # 8 (2^(4-1))
@show nmagnitudes_subnormal(Float8_4)  # 7 (8-1)
@show nvalues_prenormal(Float8_4)      # 15 (2*8-1)

# Generate all values
values = value_seq(Float8_4)
println("Total values generated: $(length(values))")
println("NaN count: $(count(isnan, values))")  
println("Finite count: $(count(isfinite, values))")
```

### Example 2: 16-bit Unsigned Extended Float with 8 Significand Bits

```julia
struct UFloat16_8 <: AkoUnsignedExtended{16, 8} end

# Extended type properties
@show is_unsigned(UFloat16_8)    # true
@show is_extended(UFloat16_8)    # true
@show nInfs(UFloat16_8)          # 1 (+∞ only)
@show nPosInfs(UFloat16_8)       # 1
@show nNegInfs(UFloat16_8)       # 0

# Bit allocation (unsigned gets extra exponent bit)
@show nbits_exp(UFloat16_8)       # 9 (16 - 8 + 1)
@show exp_bias(UFloat16_8)        # 256 (2^(16-8))

# Value counts
@show nvalues_finite(UFloat16_8)  # 65534 (65535 - 1 inf)
@show nmagnitudes(UFloat16_8)    # 65535 (all non-NaN)

# Generate values  
values = value_seq(UFloat16_8)
inf_count = count(isinf, values)
println("Infinity values: $inf_count")
```

### Example 3: Comparing Signed vs Unsigned Layouts

```julia
struct SignedFloat{B,S} <: AkoSignedFinite{B,S} end
struct UnsignedFloat{B,S} <: AkoUnsignedFinite{B,S} end

function compare_layouts(bits, sigbits)
    S = SignedFloat{bits, sigbits}
    U = UnsignedFloat{bits, sigbits}
    
    println("Comparing $(bits)-bit floats with $(sigbits) significand bits:")
    println("                    Signed  Unsigned")
    println("Exponent bits:      $(nbits_exp(S))       $(nbits_exp(U))")
    println("Exponent bias:      $(exp_bias(S))       $(exp_bias(U))")  
    println("Max unbiased exp:   $(exp_unbiased_max(S))       $(exp_unbiased_max(U))")
    println("Total magnitudes:   $(nmagnitudes(S))     $(nmagnitudes(U))")
end

compare_layouts(8, 4)
# Output:
# Comparing 8-bit floats with 4 significand bits:
#                     Signed  Unsigned  
# Exponent bits:      4       5
# Exponent bias:      8       16
# Max unbiased exp:   7       15
# Total magnitudes:   128     255
```

### Example 4: Exploring Value Distributions

```julia
struct TestFloat <: AkoSignedExtended{10, 5} end

function analyze_value_distribution(T)
    println("Value distribution for $(T):")
    println("Total bits: $(nbits(T)), Significand: $(nbits_sig(T))")
    println()
    
    # Special values
    println("Special values:")
    println("  NaN: $(nNaNs(T))")
    println("  Zeros: $(nZeros(T))")  
    println("  +∞: $(nPosInfs(T))")
    println("  -∞: $(nNegInfs(T))")
    println()
    
    # Normal vs subnormal
    println("Normal/Subnormal breakdown:")
    println("  Subnormal values: $(nvalues_subnormal(T))")
    println("  Normal values: $(nvalues_normal(T))")
    println("  Extended normal: $(nvalues_normal_extended(T))")
    println()
    
    # Sign distribution  
    println("Sign distribution:")
    println("  Positive: $(nvalues_positive(T))")
    println("  Negative: $(nvalues_negative(T))")
    println("  Non-negative: $(nvalues_nonneg(T))")
    println()
    
    # Verification
    total = nNaNs(T) + nZeros(T) + nInfs(T) + nvalues_subnormal(T) + nvalues_normal(T)
    println("Verification: $(total) = $(nvalues(T)) ✓")
end

analyze_value_distribution(TestFloat)
```

## Advanced Usage

### Custom Value Sequence Processing

```julia
function analyze_value_gaps(T)
    """Analyze gaps between consecutive finite values."""
    values = value_seq(T)
    finite_vals = filter(isfinite, values)
    sort!(finite_vals)
    
    gaps = diff(finite_vals)
    
    println("Value gap analysis for $(T):")
    println("Min gap: $(minimum(gaps))")
    println("Max gap: $(maximum(gaps))")  
    println("Mean gap: $(sum(gaps)/length(gaps))")
    
    # Find largest gaps
    gap_indices = sortperm(gaps, rev=true)[1:5]
    println("\nLargest gaps:")
    for (i, idx) in enumerate(gap_indices)
        println("  $i. $(gaps[idx]) between $(finite_vals[idx]) and $(finite_vals[idx+1])")
    end
end
```

### Type-Generic Algorithms

```julia
function precision_analysis(T::Type{<:AbstractAIFloat})
    """Generic analysis that works for any AbstractAIFloat type."""
    
    # Compute relative precision at different scales
    values = value_seq(T)
    finite_vals = filter(isfinite, values)
    positive_vals = filter(x -> x > 0, finite_vals)
    sort!(positive_vals)
    
    # Sample different magnitude ranges
    n = length(positive_vals)
    sample_indices = [1, n÷4, n÷2, 3*n÷4, n]
    
    println("Relative precision analysis for $(T):")
    println("Value\t\tNext Value\tRelative Gap")
    
    for i in sample_indices[1:end-1]
        val = positive_vals[i]
        next_val = positive_vals[i+1]
        rel_gap = (next_val - val) / val
        println("$(val)\t$(next_val)\t$(rel_gap)")
    end
end
```

### Performance Optimization

```julia
# Efficient batch operations using type properties
function batch_type_analysis(types::Vector{Type})
    """Efficiently analyze multiple types."""
    
    results = Dict{Type, Dict{Symbol, Any}}()
    
    for T in types
        # Pre-compute commonly used values
        bits = nbits(T)
        sig_bits = nbits_sig(T)
        
        results[T] = Dict(
            :bits => bits,
            :sig_bits => sig_bits,
            :signed => is_signed(T),
            :extended => is_extended(T),
            :total_values => 1 << bits,  # More efficient than nvalues(T)
            :finite_values => nvalues_finite(T),
            :dynamic_range => exp_value_max(T) / exp_value_min(T)
        )
    end
    
    return results
end
```

## Performance Considerations

### Memory Usage

- **Type-level computations**: All property functions operate on types, not instances, with zero runtime memory overhead
- **Value sequences**: `value_seq(T)` generates complete value arrays - memory usage is O(2^nbits)
- **Lazy evaluation**: Consider using iterators for large bit widths:

```julia
# For large types, use iterators instead of materializing full sequences
function iter_finite_values(T)
    values = value_seq(T)
    Iterators.filter(isfinite, values)
end
```

### Compilation Performance

- **Type specialization**: All functions are specialized on type parameters for optimal performance
- **Compile-time evaluation**: Many properties can be computed at compile time
- **@inline annotations**: Critical path functions are marked `@inline` for zero-cost abstractions

### Scaling Guidelines

| Bit Width | Total Values | Memory (Float64) | Recommended Use |
|-----------|--------------|------------------|-----------------|
| 3-bit     | 8           | 64 B            | ✅ Minimal testing, proof of concept |
| 4-bit     | 16          | 128 B           | ✅ Toy examples, algorithm verification |
| 5-bit     | 32          | 256 B           | ✅ Educational demonstrations |
| 6-bit     | 64          | 512 B           | ✅ Small-scale experiments |
| 7-bit     | 128         | 1 KB            | ✅ Research prototypes |
| 8-bit     | 256         | 2 KB            | ✅ Development, testing |
| 10-bit    | 1,024       | 8 KB            | ✅ AI model components |
| 12-bit    | 4,096       | 32 KB           | ✅ Production inference |
| 14-bit    | 16,384      | 128 KB          | ⚠️ Large models, use iterators for sequences |

---
---

*This documentation covers the complete AbstractAIFloat API. For additional examples and advanced use cases, see the test suite and example implementations.*