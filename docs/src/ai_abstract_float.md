(generated by Claude Sonnet 4 2025-06-08T10:17Z)
# AbstractAIFloat Documentation

A comprehensive floating-point type system for AI applications with configurable precision and special value handling.

## Table of Contents

- [Overview](#overview)
- [Type Hierarchy](#type-hierarchy)
- [Quick Start](#quick-start)
- [API Reference](#api-reference)
- [Examples](#examples)
- [Advanced Usage](#advanced-usage)
- [Performance Considerations](#performance-considerations)

## Overview

The `AbstractAIFloat` system provides a flexible framework for defining custom floating-point types optimized for AI and machine learning applications. It supports:

- **Configurable bit widths** and significand precision
- **Signed and unsigned** variants
- **Finite and extended** (with infinity) representations
- **Comprehensive introspection** functions for type properties
- **Value sequence generation** for systematic exploration of the number space

### Key Features

- 🎯 **Precision Control**: Customize total bits and significand bits independently
- 🔄 **Sign Variants**: Support both signed and unsigned number representations  
- ♾️ **Infinity Handling**: Choose finite-only or extended (with ±∞) representations
- 📊 **Rich Metadata**: Extensive functions to query type properties and counts
- 🎲 **Value Generation**: Built-in functions to generate complete value sequences

## Type Hierarchy

```julia
AbstractAIFloat{Bits, SigBits, IsSigned} <: AbstractFloat
├── AbstractSigned{Bits, SigBits}   # IsSigned = true
│   ├── AkoSignedFinite{Bits, SigBits}     # No infinities
│   └── AkoSignedExtended{Bits, SigBits}   # With ±∞
└── AbstractUnsigned{Bits, SigBits} # IsSigned = false  
    ├── AkoUnsignedFinite{Bits, SigBits}   # No infinities
    └── AkoUnsignedExtended{Bits, SigBits} # With +∞ only
```

### Type Parameters

- **`Bits`**: Total number of bits in the representation (e.g., 8, 16, 32)
- **`SigBits`**: Number of significand bits including implicit leading bit
- **`IsSigned`**: Boolean indicating if the type supports negative values

## Quick Start

```julia
# Define concrete types by subtyping the abstracts
struct MyFloat8_4 <: AkoSignedFinite{8, 4} end
struct MyUFloat8_4 <: AkoUnsignedFinite{8, 4} end

# Query basic properties
nBits(MyFloat8_4)     # 8
nSigBits(MyFloat8_4)  # 4  
nFracBits(MyFloat8_4) # 3
is_signed(MyFloat8_4) # true
is_finite(MyFloat8_4) # true

# Count different value types
nValues(MyFloat8_4)         # 256 (total possible values)
nFiniteValues(MyFloat8_4)   # 255 (excluding NaN)
nPositiveValues(MyFloat8_4) # 127 (positive finite values)

# Generate value sequences
values = value_sequence(MyFloat8_4)  # Complete sequence of representable values
```

## API Reference

### Type Predicates

Functions to determine type characteristics:

#### `is_signed(T)` / `is_unsigned(T)`
```julia
is_signed(::Type{T}) where {T<:AbstractAIFloat} → Bool
is_unsigned(::Type{T}) where {T<:AbstractAIFloat} → Bool
```
Test whether a type supports negative values.

**Examples:**
```julia
is_signed(AkoSignedFinite{8,4})   # true
is_unsigned(AkoUnsignedFinite{8,4}) # true
```

#### `is_finite(T)` / `is_extended(T)`
```julia
is_finite(::Type{T}) where {T<:AbstractAIFloat} → Bool  
is_extended(::Type{T}) where {T<:AbstractAIFloat} → Bool
```
Test whether a type includes infinity values.

**Examples:**
```julia
is_finite(AkoSignedFinite{8,4})   # true
is_extended(AkoSignedExtended{8,4}) # true
```

#### Abstract Type Predicates

For use with abstract supertypes:

```julia
isa_signed(@nospecialize(T::Type{<:AbstractSigned})) → Bool
isa_unsigned(@nospecialize(T::Type{<:AbstractUnsigned})) → Bool  
isa_finite(@nospecialize(T::Type{<:AkoSignedFinite})) → Bool
isa_extended(@nospecialize(T::Type{<:AkoSignedExtended})) → Bool
```

### Basic Properties

#### Bit Layout Functions
```julia
nBits(T) → Int          # Total bits in representation
nSigBits(T) → Int       # Significand bits (including implicit bit)
nFracBits(T) → Int      # Fractional bits (nSigBits - 1)
nExpBits(T) → Int       # Exponent bits
```

**Note:** Unsigned types get an extra exponent bit since no sign bit is needed.

#### Value Counts
```julia
nValues(T) → Int                # Total representable values (2^nBits)
nNumericValues(T) → Int         # Non-NaN values  
nNonzeroNumericValues(T) → Int  # Non-NaN, non-zero values
```

### Special Value Counts

#### NaN, Zero, and Infinity Counts
```julia
nNaNs(T) → Int      # Always 1
nZeros(T) → Int     # Always 1  
nInfs(T) → Int      # 0 for finite, 1 for unsigned extended, 2 for signed extended
nPosInfs(T) → Int   # Positive infinities
nNegInfs(T) → Int   # Negative infinities (0 for unsigned)
```

### Magnitude and Sign Counts

#### Magnitude Functions
```julia
nMagnitudes(T) → Int           # Total magnitude values
nNonzeroMagnitudes(T) → Int    # Non-zero magnitude values
nFiniteMagnitudes(T) → Int     # Finite magnitude values
```

#### Sign-Specific Counts
```julia
nNonnegValues(T) → Int         # Non-negative values (≥ 0)
nPositiveValues(T) → Int       # Positive values (> 0)  
nNegativeValues(T) → Int       # Negative values (< 0)
nFinitePositiveValues(T) → Int # Finite positive values
nFiniteNegativeValues(T) → Int # Finite negative values
```

### Normal and Subnormal Counts

#### Subnormal (Denormalized) Values
```julia
nPrenormalMagnitudes(T) → Int  # Magnitudes in subnormal range (including zero)
nSubnormalMagnitudes(T) → Int  # Non-zero subnormal magnitudes
nPrenormalValues(T) → Int      # Subnormal values (including zero)
nSubnormalValues(T) → Int      # Non-zero subnormal values
```

#### Normal Values  
```julia
nNormalMagnitudes(T) → Int        # Normal magnitude values
nNormalValues(T) → Int            # Normal values
nExtendedNormalMagnitudes(T) → Int # Normal + infinity magnitudes
nExtendedNormalValues(T) → Int    # Normal + infinity values
```

### Exponent System

#### Exponent Properties
```julia
expBias(T) → Int              # Exponent bias
expUnbiasedMax(T) → Int       # Maximum unbiased exponent
expUnbiasedMin(T) → Int       # Minimum unbiased exponent  
expUnbiasedValues(T) → Vector # All unbiased exponent values
expMaxValue(T) → Float64      # 2^expUnbiasedMax
expMinValue(T) → Float64      # 2^expUnbiasedMin
```

#### Exponent Counts
```julia
nExpValues(T) → Int           # Total exponent values (2^nExpBits)
nNonzeroExpValues(T) → Int    # Non-zero exponent values
```

### Significand Properties

```julia
nSigMagnitudes(T) → Int       # Significand magnitude values (2^nSigBits)
nNonzeroSigMagnitudes(T) → Int # Non-zero significand magnitudes
nFracMagnitudes(T) → Int      # Fractional part values (2^nFracBits)  
nNonzeroFracMagnitudes(T) → Int # Non-zero fractional parts
```

### Value Generation Functions

#### Magnitude Step Functions
```julia
prenormal_magnitude_steps(T) → Vector{Float64}
normal_magnitude_steps(T) → Vector{Float64}
```
Generate normalized magnitude steps for subnormal and normal ranges.

#### Foundation Functions
```julia
foundation_extremal_exps(T) → Tuple{Int, Int}    # (min_exp, max_exp)
foundation_exps(T) → UnitRange{Int}              # Range of foundation exponents
foundation_magnitudes(T) → Vector{Float64}       # Base magnitude values
```

#### Complete Value Sequences
```julia
value_sequence(T) → Vector{Float64}
```
Generate the complete sequence of representable values for the type, including special values (NaN, ±∞) in appropriate positions.

**Behavior by type:**
- **Finite types**: Last value is NaN
- **Extended types**: Penultimate value is +∞ (or +∞/-∞ for signed), last is NaN
- **Signed types**: Negative values appended, with NaN replacing -0

### Utility Functions

```julia
two_pow(x::Integer) → Float32  # Efficient 2^x computation
normal_exp_stride(T) → Int     # Stride between exponent groups
exp_unbiased_magnitude_strides(T) → Vector{Int} # Exponent strides for magnitudes
pow2_foundation_exps(T, res) → Vector{Float32}  # 2^exponent values
```

## Examples

### Example 1: 8-bit Signed Finite Float with 4 Significand Bits

```julia
struct Float8_4 <: AkoSignedFinite{8, 4} end

# Basic properties
@show nBits(Float8_4)          # 8
@show nSigBits(Float8_4)       # 4  
@show nExpBits(Float8_4)       # 4 (8 - 4 = 4)
@show expBias(Float8_4)        # 8 (2^(8-4-1) = 2^3)

# Value counts
@show nValues(Float8_4)        # 256 (2^8)
@show nFiniteValues(Float8_4)  # 255 (no infinities)
@show nPositiveValues(Float8_4) # 127 (half minus zero)
@show nNegativeValues(Float8_4) # 127

# Subnormal analysis  
@show nPrenormalMagnitudes(Float8_4)  # 8 (2^(4-1))
@show nSubnormalMagnitudes(Float8_4)  # 7 (8-1)
@show nPrenormalValues(Float8_4)      # 15 (2*8-1)

# Generate all values
values = value_sequence(Float8_4)
println("Total values generated: $(length(values))")
println("NaN count: $(count(isnan, values))")  
println("Finite count: $(count(isfinite, values))")
```

### Example 2: 16-bit Unsigned Extended Float with 8 Significand Bits

```julia
struct UFloat16_8 <: AkoUnsignedExtended{16, 8} end

# Extended type properties
@show is_unsigned(UFloat16_8)    # true
@show is_extended(UFloat16_8)    # true
@show nInfs(UFloat16_8)          # 1 (+∞ only)
@show nPosInfs(UFloat16_8)       # 1
@show nNegInfs(UFloat16_8)       # 0

# Bit allocation (unsigned gets extra exponent bit)
@show nExpBits(UFloat16_8)       # 9 (16 - 8 + 1)
@show expBias(UFloat16_8)        # 256 (2^(16-8))

# Value counts
@show nFiniteValues(UFloat16_8)  # 65534 (65535 - 1 inf)
@show nMagnitudes(UFloat16_8)    # 65535 (all non-NaN)

# Generate values  
values = value_sequence(UFloat16_8)
inf_count = count(isinf, values)
println("Infinity values: $inf_count")
```

### Example 3: Comparing Signed vs Unsigned Layouts

```julia
struct SignedFloat{B,S} <: AkoSignedFinite{B,S} end
struct UnsignedFloat{B,S} <: AkoUnsignedFinite{B,S} end

function compare_layouts(bits, sigbits)
    S = SignedFloat{bits, sigbits}
    U = UnsignedFloat{bits, sigbits}
    
    println("Comparing $(bits)-bit floats with $(sigbits) significand bits:")
    println("                    Signed  Unsigned")
    println("Exponent bits:      $(nExpBits(S))       $(nExpBits(U))")
    println("Exponent bias:      $(expBias(S))       $(expBias(U))")  
    println("Max unbiased exp:   $(expUnbiasedMax(S))       $(expUnbiasedMax(U))")
    println("Total magnitudes:   $(nMagnitudes(S))     $(nMagnitudes(U))")
end

compare_layouts(8, 4)
# Output:
# Comparing 8-bit floats with 4 significand bits:
#                     Signed  Unsigned  
# Exponent bits:      4       5
# Exponent bias:      8       16
# Max unbiased exp:   7       15
# Total magnitudes:   128     255
```

### Example 4: Exploring Value Distributions

```julia
struct TestFloat <: AkoSignedExtended{10, 5} end

function analyze_value_distribution(T)
    println("Value distribution for $(T):")
    println("Total bits: $(nBits(T)), Significand: $(nSigBits(T))")
    println()
    
    # Special values
    println("Special values:")
    println("  NaN: $(nNaNs(T))")
    println("  Zeros: $(nZeros(T))")  
    println("  +∞: $(nPosInfs(T))")
    println("  -∞: $(nNegInfs(T))")
    println()
    
    # Normal vs subnormal
    println("Normal/Subnormal breakdown:")
    println("  Subnormal values: $(nSubnormalValues(T))")
    println("  Normal values: $(nNormalValues(T))")
    println("  Extended normal: $(nExtendedNormalValues(T))")
    println()
    
    # Sign distribution  
    println("Sign distribution:")
    println("  Positive: $(nPositiveValues(T))")
    println("  Negative: $(nNegativeValues(T))")
    println("  Non-negative: $(nNonnegValues(T))")
    println()
    
    # Verification
    total = nNaNs(T) + nZeros(T) + nInfs(T) + nSubnormalValues(T) + nNormalValues(T)
    println("Verification: $(total) = $(nValues(T)) ✓")
end

analyze_value_distribution(TestFloat)
```

## Advanced Usage

### Custom Value Sequence Processing

```julia
function analyze_value_gaps(T)
    """Analyze gaps between consecutive finite values."""
    values = value_sequence(T)
    finite_vals = filter(isfinite, values)
    sort!(finite_vals)
    
    gaps = diff(finite_vals)
    
    println("Value gap analysis for $(T):")
    println("Min gap: $(minimum(gaps))")
    println("Max gap: $(maximum(gaps))")  
    println("Mean gap: $(sum(gaps)/length(gaps))")
    
    # Find largest gaps
    gap_indices = sortperm(gaps, rev=true)[1:5]
    println("\nLargest gaps:")
    for (i, idx) in enumerate(gap_indices)
        println("  $i. $(gaps[idx]) between $(finite_vals[idx]) and $(finite_vals[idx+1])")
    end
end
```

### Type-Generic Algorithms

```julia
function precision_analysis(T::Type{<:AbstractAIFloat})
    """Generic analysis that works for any AbstractAIFloat type."""
    
    # Compute relative precision at different scales
    values = value_sequence(T)
    finite_vals = filter(isfinite, values)
    positive_vals = filter(x -> x > 0, finite_vals)
    sort!(positive_vals)
    
    # Sample different magnitude ranges
    n = length(positive_vals)
    sample_indices = [1, n÷4, n÷2, 3*n÷4, n]
    
    println("Relative precision analysis for $(T):")
    println("Value\t\tNext Value\tRelative Gap")
    
    for i in sample_indices[1:end-1]
        val = positive_vals[i]
        next_val = positive_vals[i+1]
        rel_gap = (next_val - val) / val
        println("$(val)\t$(next_val)\t$(rel_gap)")
    end
end
```

### Performance Optimization

```julia
# Efficient batch operations using type properties
function batch_type_analysis(types::Vector{Type})
    """Efficiently analyze multiple types."""
    
    results = Dict{Type, Dict{Symbol, Any}}()
    
    for T in types
        # Pre-compute commonly used values
        bits = nBits(T)
        sig_bits = nSigBits(T)
        
        results[T] = Dict(
            :bits => bits,
            :sig_bits => sig_bits,
            :signed => is_signed(T),
            :extended => is_extended(T),
            :total_values => 1 << bits,  # More efficient than nValues(T)
            :finite_values => nFiniteValues(T),
            :dynamic_range => expMaxValue(T) / expMinValue(T)
        )
    end
    
    return results
end
```

## Performance Considerations

### Memory Usage

- **Type-level computations**: All property functions operate on types, not instances, with zero runtime memory overhead
- **Value sequences**: `value_sequence(T)` generates complete value arrays - memory usage is O(2^nBits)
- **Lazy evaluation**: Consider using iterators for large bit widths:

```julia
# For large types, use iterators instead of materializing full sequences
function iter_finite_values(T)
    values = value_sequence(T)
    Iterators.filter(isfinite, values)
end
```

### Compilation Performance

- **Type specialization**: All functions are specialized on type parameters for optimal performance
- **Compile-time evaluation**: Many properties can be computed at compile time
- **@inline annotations**: Critical path functions are marked `@inline` for zero-cost abstractions

### Scaling Guidelines

| Bit Width | Total Values | Memory (Float64) | Recommended Use |
|-----------|--------------|------------------|-----------------|
| 3-bit     | 8           | 64 B            | ✅ Minimal testing, proof of concept |
| 4-bit     | 16          | 128 B           | ✅ Toy examples, algorithm verification |
| 5-bit     | 32          | 256 B           | ✅ Educational demonstrations |
| 6-bit     | 64          | 512 B           | ✅ Small-scale experiments |
| 7-bit     | 128         | 1 KB            | ✅ Research prototypes |
| 8-bit     | 256         | 2 KB            | ✅ Development, testing |
| 10-bit    | 1,024       | 8 KB            | ✅ AI model components |
| 12-bit    | 4,096       | 32 KB           | ✅ Production inference |
| 14-bit    | 16,384      | 128 KB          | ⚠️ Large models, use iterators for sequences |

---
---

*This documentation covers the complete AbstractAIFloat API. For additional examples and advanced use cases, see the test suite and example implementations.*